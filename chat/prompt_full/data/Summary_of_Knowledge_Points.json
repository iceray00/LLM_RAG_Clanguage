[
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00001",
        "title": "程序的概念",
        "content": "一组计算机能识别和执行的指令",
        "tags": ["C语言基础知识" ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00002",
        "title": "机器指令的概念",
        "content": "计算机能直接识别和接受的二进制代码",
        "tags":["C语言基础知识"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00003",
        "title": "机器语言的概念",
        "content": "机器指令的集合",
        "tags":["C语言基础知识"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00004",
        "title": "符号语言的别称",
        "content": "符号汇编语言或汇编语言",
        "tags":["C语言基础知识","符号语言"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00005",
        "title": "符号语言的使用",
        "content": "符号语言用一些英文字母和数字表示一个指令",
        "tags":["C语言基础知识","符号语言"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00006",
        "title": "低级语言的概念",
        "content": "完全依赖于具体机器特性，是面向机器的语言，分为机器语言和汇编语言",
        "tags":["C语言基础知识"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00007",
        "title": "高级语言的概念",
        "content": "功能很强，不依赖于具体机器，用它写出的程序对任何型号的计算机都适用（或只需做很少的修改），他与具体机器距离较“远”",
        "tags":["C语言基础知识"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00008",
        "title": "高级语言的发展阶段",
        "content": "1.非结构化的语言。初期的语言属于非结构化的语言，编程风格比较随意，只要符合语法风格即可，没有严格的规范要求，程序中的流程可以随意跳转。人们往往追求程序执行的效率而采用了许多“小技巧”，是程序变得难以阅读和维护。早期的BASIC，FORTRAN和ALGOL等都属于非结构化的语言。  2.结构化语言。为了解决以上问题，提出了“结构化程序设计方法”，规定程序必须具有良好的基本结构（顺序结构、选择结构、循环结构）构成，程序中的流程不允许随意跳转，程序总是由上而下顺序执行各个基本结构。这种程序结构清晰，易于编写、阅读和维护。QBASIC，FORTRAN 77和C语言等属于结构化的语言，这些语言的特点是支持结构化程序设计方法。  3.面向对象的语言。C++，C#，Visual Basic和Java等语言是支持面向对象程序设计方法的语言。",
        "tags":["C语言基础知识","发展阶段"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00009",
        "title": "非结构化语言的分类",
        "content": "早期的BASIC，FORTRAN和ALGOL等都属于非结构化的语言",
        "tags":["C语言基础知识","非结构化语言","分类"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00010",
        "title": "结构化语言的分类",
        "content": "QBASIC，FORTRAN 77和C语言等属于结构化的语言",
        "tags":["C语言基础知识","结构化语言","分类"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00011",
        "title": "面向对象语言的分类",
        "content": "C++，C#，Visual Basic和Java等语言是支持面向对象程序设计方法的语言。",
        "tags":["C语言基础知识","面向对象语言","分类"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00012",
        "title": "C语言的定义",
        "content": "C语言是一种用途广泛、功能强大、使用灵活的过程性编程语言，既可用于编写应用软件，又可用于编写系统软件",
        "tags":["C语言基础知识","定义"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00013",
        "title": "C语言的特点",
        "content": "1.语言简洁、紧凑，使用方便、灵活。C语言一共只有37个关键字、9种控制语句，程序书写形式自由，主要用小写字母表示，压缩了一切不必要的成分。C语言程序比其它许多高级语言简练，源程序短，因此输入程序时工作量少。  2.运算符丰富。C语言的运算符包含的范围很广泛，共有34种运算符。C语言把括号、赋值和强制类型转换等都作为运算符处理，从而使C语言的运算类型极其丰富，表达式类型多样化。灵活使用各种运算符可以实现在其他高级语言中难以实现的运算  3.数据类型丰富。C语言提供的数据类型包括整型、浮点型、字符型、数组类型、指针类型和共用体类型，C 99又扩充了复数浮点类型、超长整型（long long）和布尔类型（bool）等。尤其是指针类型数据，使用十分灵活和多样化，能用来实现各种复杂的数据结构（如链表、树、栈等）的运算。  4.具有结构化的控制语句（如if……else语句、while语句、switch语句和for语句）。用函数作为程序的模块单位，便于实现程序的模块化。C语言是完全模块化和结构化的语言。  5.语法限制不太严格，程序设计自由度大。例如对数组下标越界不进行检查，由程序编写者自己保证程序的正确。对变量类型使用比较灵活，例如，整形量与字符型数据以及逻辑型数据可以通用。一般的高级语言语法检查比较严，能检查出几乎所有的语法错误，而C语言为了使编写者有较大的自由度放宽了语法检查。程序员应当仔细检查程序，保证其正确，不要过分依赖C语言编译程序查错。限制与灵活是一对矛盾，限制严格，就失去灵活性。而强调灵活，就必然放松限制，对于不熟练的人员，编写一个正确的C语言程序可能会比编写一个其他高级语言程序难一些。也就是说，对用C语言的人要求更高一些。  6.C语言允许直接访问物理地址，能进行位（bit）操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作。因此C语言既具有高级语言的功能，又具有低级语言的许多功能，可用来编写系统软件。C语言的这种双重性，使它既是成功的系统描述语言，又是通用的程序设计语言。  7.用C语言编写的程序可移植性好。由于C的编译系统相当简洁，因此很容易移植到新的系统。而且C编译系统在新的系统上运行时，可以直接编译“标准链接库”中的大部分功能，不需要修改源代码，因为标准链接库是用可移植的 C语言写的。因此，几乎在所有的计算机系统中都可以使用C语言。  8.生成目标代码质量高，程序执行效率高。C原来是专门为编写系统软件而设计的，许多大的应用软件也都使用C语言编写，这是因为C语言的可移植性好，硬件控制能力高，表达和运算能力强。许多以前只能用汇编语言处理的问题，后来可以改用C语言来处理了。目前C的主要用途之一是编写嵌入式系统程序，由于具有上述优点，使C语言应用面十分广泛，许多应用软件也用C语言编写。",
        "tags":["C语言基础知识"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00014",
        "title": "C语言注释方法",
        "content": "C语言允许用两种注释方式：1.以//开始的单行注释。如上面介绍的注释，这种注释可以单独占一行，也可以出现在一行中其他内容的右侧，此种注释的范围从//开始，以换行符结束。也就是说这种注释不能跨行，如果注释内容一行写不下，可以用多个单行注释。  2.以/*开始，以*/结束的快式注释，这种注释可以包括多项内容，它可以单独占一行（再行开头以/*开始，行末以*/结束），也可以包含多行。编译系统在发现一个/*后会开始找注释结束符*/，把二者间的内容作为注释。",
        "tags":["C语言基础知识","注释"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00015",
        "title": "C语言程序的结构特点",
        "content": "1.一个程序由一个或多个源程序文件组成。  2.函数是C程序的主要组成部分。程序的几乎全部工作都是由各个函数分别完成的，函数是C程序的基本单位，在设计良好的程序中，每个函数都用来实现一个或几个特定的功能。编写c程序的工作主要就是编写一个函数。  3.一个函数包括两个部分。 (1) 函数首部及函数的第一行，包括函数名、函数类型、函数属性、函数参数（形式参数）名、参数类型。 (2) 函数体。即函数首部下面的花括号内的部分。如果在一个函数中包含有多层花括号，则最外层的一对花括号是函数体的范围。  4.程序总是从main函数开始执行的，而不论main函数在整个程序中的位置如何（main函数可以放在程序最前头，也可以放在程序最后，或在一些函数之前、另一些函数之后）。  5.程序中要求计算机的操作是由函数中的C语句完成的。如赋值、输入输出数据的操作都是由相应的C语句实现的。  6.在每个数据声明和数据的语句的最后必须有一个分号。分号是C语句的必要组成部分。7.C语言本身不提供输入输出语句。输入和输出的操作是由库函数scanf和printf等函数来完成的。C语言对输入输出实行”函数化“。由于输入输出操作涉及具体的计算机设备，把输入输出操作用库函数实现，就可以使C语言本身的规模较小，编译程序简单，很容易在各种程序机器上实现程序具有可移植性。  8.程序应当包含注释，一个好的、有使用价值的源程序都应当加上必要的注释，以增加程序的可读性。",
        "tags":["C语言基础知识","程序结构","特点"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00016",
        "title": "C源程序编译和运行的过程",
        "content": "1.上机输入和编辑源程序。  2.对源程序进行编译，先用C编译系统提供的“预处理器”（又称“预处理程序”或“预编译器”）对程序中的预处理指令进行编译预处理。  3.进行连接处理。  4.运行可执行程序，得到运行结果",
        "tags":["编译","运行"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00017",
        "title": "算法的定义",
        "content": "为解决一个问题而采取的方法和步骤叫做算法4",
        "tags":["算法"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00018",
        "title": "计算机算法的分类",
        "content": "数值运算算法和非数值运算算法",
        "tags":["C语言基础知识","算法"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00019",
        "title": "算法的特点",
        "content": "1.有穷性。一个算法应该包含有限的操作步骤，而不能是无限的。  2.确定性。算法中的每一个步骤都应当是确定的。  3.有零个或多个输入。所谓输入是指在执行算法是需要从外界取得必要的信息。  4.有一个或多个输出。  5.有效性。算法中的每一个步骤都应当能有效地执行。",
        "tags":["C语言基础知识","算法"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00020",
        "title": "算法的表示方法",
        "content": "自然语言、传统流程图，结构化流程图和伪代码等",
        "tags":["C语言基础知识","算法"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00021",
        "title": "C语言三种基本结构是什么？",
        "content": "1.顺序结构  2.选择结构  3.循环结构 (1)当型（while型）循环结构 (2)直到型（until型）循环结构  基本结构并不只局限于以上三种只要具有四个基本特点（只有一个入口、只有一个出口、结构内的每一部分都有机会被执行到、结构内不存在“死循环”（无终止的循环））的都可以作为基本结构，并由这些基本结构组成结构化程序",
        "tags":["C语言基础知识","结构"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00022",
        "title": "伪代码的概念",
        "content": "伪代码是用介于自然语言和计算机语言之间的文字和符号来描述算法",
        "tags":["C语言基础知识","伪代码"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00023",
        "title": "书写伪代码的规则？",
        "content": "用为代码写算法并无固定的、严格的语法规则，可以用英文，也可以中英文混用，只要把意思表达清楚，便于书写和阅读即可，书写的格式要写成清晰易读的格式。",
        "tags":["C语言基础知识","伪代码"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00024",
        "title": "如何保证得到结构化的程序",
        "content": "1.自顶向下  2.逐步细化  3.模块化设计  4.结构化编码",
        "tags":["C语言基础知识","结构化","程序"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00025",
        "title": "结构化程序的原因",
        "content": "结构化程序便于编写、阅读、修改和维护，这就减少了程序出错的机会，提高了程序的可读性，保证了程序的质量。",
        "tags":["C语言基础知识","结构化"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00026",
        "title": "常量的概念",
        "content": "在程序运行过程中，其值不能被改变的量称为常量",
        "tags":["C语言基础知识","常量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00027",
        "title": "常量的分类",
        "content": "1.整型常量。如1000，12345，0，-345等都是整型常量  2.实型常量。有两种表示形式：(1)十进制小数形式，由数字和小数点组成。如123.456，0.345，-56.79，0.0，12.0等 (2)指数形式，如12.34e3，-346.87e-25等  3.字符常量。有两种形式的字符常量：(1)普通字符，用单撇号括起来的一个字符，如：'a','Z','3','?','12'等.请注意：单撇号只是界限符，字符常量只能是一个字符，不包含单撇号。'a'和'A'是不同的字符。(2)转义字符。  4.字符串常量。如\"boy\",\"123\"等，用双撇号把若干个字符括起来，字符串常量是双撇号中的全部字符（但不包括双撇号本身）。注意双撇号不能用单撇号代替。  5.符号常量。用#define指令，指定用一个符号名称代表一个常量 ",
        "tags":["C语言基础知识","常量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00028",
        "title": "使用符号常量的好处",
        "content": "1.含义清楚。应尽量使用“见名知义”的变量名和符号常量。  2.在需要改变程序中多处用到的同一个常量时，能做到“一改全改”。",
        "tags":["C语言基础知识","常量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00029",
        "title": "变量的使用",
        "content": "变量必须先定义，后使用。在定义时指定该变量的名字和类型。一个变量应该有一个名字，以便被引用。请注意区分变量名和变量值这两个不同的概念。",
        "tags":["变量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00030",
        "title": "变量名的概念",
        "content": "变量名实际上是以一个名字代表的一个存储地址。在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。",
        "tags":["变量","变量名"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00031",
        "title": "变量值的概念",
        "content": "变量值是从变量中取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据。",
        "tags":["变量","变量值"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00032",
        "title": "常变量的概念",
        "content": "在定义变量时，前面加一个关键字const即为常变量",
        "tags":["常变量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00033",
        "title": "常变量与常量的异同",
        "content": "常变量具有变量的基本属性：有类型、占存储单元，只是不允许改变其值。可以说，常变量是有名字的不变量，而常量是没有名字的不变量，有名字就便于在程序中被引用。",
        "tags":["常变量","常量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00034",
        "title": "标识符的概念",
        "content": "在计算机高级语言中，用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为标识符。简单来说，标识符就是一个对象的名字。",
        "tags":["标识符"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00035",
        "title": "如何正确定义标识符",
        "content": "C语言规定标识符只能由字母、数字和下划线3种字符组成，且第1个字符必须为字母或下划线。",
        "tags":["标识符"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00036",
        "title": "C语言的数据类型",
        "content": "C语言的数据类型分为基本类型、枚举类型（enum）、空类型（void）和派生类型。基本类型分为整型类型和浮点类型，整型类型分为如下几种小类型：基本整型（int）、短整型（short int）、长整型（long int）、*双长整型（long long int）、字符型（char）、*布尔型（bool）；浮点类型分类如下：单精度浮点型（float）、双精度浮点型（double）、复数浮点型（float_complex,double_complex,long long_complex）。派生类型分为指针类型（*）、数组类型（[]）、结构体类型（struct）、共用体类型（union）、函数类型",
        "tags":["数据类型"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00037",
        "title": "如何判断常量数据类型",
        "content": "从常量的表示形式及可以判定其类型。对于字符常量很简单，只要看到有单撇号括起来的单个字符或转义字符就可以知道他是字符常量。",
        "tags":["数据类型","常量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00038",
        "title": "变量和类型的区分",
        "content": "他们是既有联系又有区别的两个概念。每一个变量都属于一个确定的类型，类型是变量的一个重要的属性，是具体存在的实体，在其占用的存储单元中可以存放数据，而类型是变量的共性，是抽象的，不占用存储单元，不能用来存放数据。",
        "tags":["变量"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00039",
        "title": "C语言提供的常见运算符",
        "content": "算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、条件运算符、逗号运算符、指针运算符、求字节数运算符、强制类型转换运算符、成员运算符、下标运算符等",
        "tags":["运算符"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00040",
        "title": "C语言语句的分类",
        "content": "1.控制语句  2.函数调用语句。函数调用语句由一个函数调用加一个分号构成。  3.表达式语句。表达式语句由一个表达式加一个分号构成。  4.空语句。可以用来做流程的转向点（流程从程序其他地方转到此语句处），也可用来作为循环语句中的循环体（循环体是空语句，表示循环体什么也不做）  5.复合语句。可以用{}把一些语句和生命括起来成为复合语句（又称语句块）",
        "tags":["C语言基础知识"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00041",
        "title": "赋值表达式的概念",
        "content": "由赋值运算符将一个变量和一个表达式连接起来的式子称为“赋值表达式”",
        "tags":["表达式"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00042",
        "title": "赋值表达式的作用",
        "content": "赋值表达式的作用是将一个表达式的值赋给一个变量，因此赋值表达式具有计算和赋值的双重功能。",
        "tags":["表达式"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00043",
        "title": "赋值时类型转换的规则",
        "content": "1.将浮点型数据赋给整型变量时，先对浮点数取整，即舍弃小数部分，然后赋予整数变量。  2.将整型数据赋给单、双精度变量时，数值不变，但以浮点数形式存储到变量中。  3.将一个double型数据赋给float变量时，先将双精度数转换为单精度，即只取6-7位，存储到float变量的4个字节中。应注意双精度数值的大小不能超过float变量的数值范围。  4.字符型数据赋给整型变量时，将字符的ASCII代码赋给整型变量。  5.将一个占字节多的整型数据赋给一个占字节少的整型变量或字符变量，只将其低字节原封不动地送到被赋值的变量（即发生“截断”）。",
        "tags":["类型转换"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00044",
        "title": "格式字符的含义",
        "content": "d，i：输入有符号的十进制整数  u：输入无符号的十进制整数  o：输入无符号的八进制整数  x，X：输入无符号的十六进制整数（大小写作用相同）  c：输入单个字符  s：输入字符串，将字符串送到一个字符数组中，在输入时以非空白字符开始，以第一个空白字符结束。字符串以串结束标志'\\0'作为其最后一个字符  f：输入实数，可以用小数形式或指数形式输入  e，E，g，G：与f作用相同，e与f、g可以互相替换（大小写作用相同）",
        "tags":["格式字符"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00045",
        "title": "scanf函数的用法",
        "content": "1.scanf函数中的格式控制后面应当是变量地址，而不是变量名。  2.如果在格式控制字符串中除了格式生命以外还有其它字符，则在输入数据时在对应的位置上应输入与输入这些字符相同的字符。  3.在用“%c”格式声明输入字符时，空格字符和“转义字符”中的字符都作为有效字符输入。  4.在输入数值数据时，如输入空格、回车、Tab键或遇非法字符（不属于数值的字符），认为该数据结束。",
        "tags":["scanf函数"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00046",
        "title": "选择语句的分类与概念",
        "content": "1.if语句，用来实现两个分支的选择结构。  2.switch语句，用来实现多分支的选择结构。",
        "tags":["选择语句"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00047",
        "title": "关系运算符的优先次序",
        "content": "关系运算符的优先级低于算术运算符，高于赋值运算符",
        "tags":["关系运算符"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00048",
        "title": "关系表达式的概念",
        "content": "用关系表达式将两个数值或数值表达式连接起来的式子，称为关系表达式。",
        "tags":["关系表达式"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00049",
        "title": "逻辑表达式的概念",
        "content": "用逻辑运算符将关系表达式或其他逻辑量连接起来的式子就是逻辑表达式。",
        "tags":["逻辑表达式"]
    },
   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00050",
        "title": "逻辑运算符的分类",
        "content": "与（&&），或（||），非（！）",
        "tags":["逻辑运算符"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00051",
        "title": "条件表达式的概念及一般形式？",
        "content": "表达式1?表达式2:表达式3，先计算出表达式1的值，表达式1的值为真（非0），自然直接到表达式2，如为假（0值），就饶过表达式2，到表达式3。",
        "tags":["条件表达式"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00052",
        "title": "while循环的特点？",
        "content": "只要当循环条件表达式为真（即给定的条件成立），就执行循环体语句。while循环的特点是先判断条件表达式，后执行循环体语句。",
        "tags":["循环"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00053",
        "title": "do while循环的特点？",
        "content": "先执行循环体，然后再检查条件是否成立，若成立，再执行循环体。do while语句的特点是，先无条件执行循环体，然后判断循环条件是否成立。",
        "tags":["循环"]
    },   {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00054",
        "title": "循环的嵌套的概念",
        "content": "一个循环体内有包含另一个完整的循环结构，称为循环的嵌套。",
        "tags":["循环"]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00055",
        "title": "`break`语句的用法",
        "content": "其作用是使流程跳到循环体之外，接着执行循环体下面的语句。且`break`语句只能用于循环语句和`switch`语句之中，而不能单独使用。",
        "tags": [
            "`break`语句",
            "提前终止循环"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00056",
        "title": "`continue`语句的用法",
        "content": "其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，转到循环体结束点之前，即直接转至循环条件检查点。（对于 `for` 循环，这通常意味着跳到更新表达式之后，重新评估循环条件；对于 `while` 和 `do...while` 循环，则立即返回到条件测试处，决定是否继续下一次迭代。）",
        "tags": [
            "`continue`语句",
            "提前结束本次循环"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00057",
        "title": "`continue`语句和`break`语句的用法区别",
        "content": "`continue`语句只结束本次循环，而不是终止整个循环的执行。而`break`语句则是结束整个循环过程，不再判断执行循环的条件是否成立。",
        "tags": [
            "`continue`语句",
            "`break`语句",
            "区别"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00058",
        "title": "在双重循环中，在内循环体内有一个`break`语句，其作用是提前终止内循环，还是提前终止整个循环？",
        "content": "提前终止内循环。即：`break`语句使得流程跳转到内循环体之外（执行内循环体下面的语句），而不是跳转到外循环体之外（执行外循环体下面的语句）。",
        "tags": [
            "`break`语句",
            "双重循环"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00059",
        "title": "数组的概念",
        "content": "数组是一组有序数据的集合。数组中各数据的排列是有一定规律的，下标代表数据在数组中的序号，一个数组名和下标可以唯一地确定数组中的元素。数组中的每一个元素都属于同一个数据类型，不能把不同类型的数据放在同一个数组中。",
        "tags": [
            "数组",
            "概念"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00060",
        "title": "一维数组的定义",
        "content": "定义一维数组的一般形式为：“`类型符 数组名[常量表达式];`”。例如：“`int a[10];`”表示定义了一个整型数组，数组名为`a`，此数组包含10个整型元素。注意，下标是从`0`开始的，不存在数组元素`a[10]`。",
        "tags": [
            "一维数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00061",
        "title": "常量表达式在数组定义中的使用",
        "content": "常量表达式中可以包括常量和符号常量，如“`int a[3+5];`”是合法的。不能包含变量，如“`int a[n];`”是不合法的。也就是说，C语言不允许对数组的大小作动态定义，即数组的大小不依赖于程序运行过程中变量的值。",
        "tags": [
            "常量表达式",
            "数组定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00062",
        "title": "怎样引用一维数组元素",
        "content": "在定义数组并对其中各元素赋值后，就可以引用数组中的元素。应注意：只能引用数组元素而不能一次整体调用整个数组全部元素的值。引用数组元素的表示形式为：“`数组名[下标]`”，例如，`a[O]`就是数组`a`中序号为`0`的元素，它和一个简单变量的地位和作用相似。“下标”可以是整型常量或整型表达式。例如下面的赋值表达式包含了对数组元素的引用：`a[0]=a[5]+a[7]-a[2*3]`，每一个数组元素都代表一个整数值。",
        "tags": [
            "一维数组",
            "引用",
            "表示形式"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00063",
        "title": "一维数组的初始化的概念",
        "content": "为了使程序简洁，常在定义数组的同时给各数组元素赋值，这称为数组的初始化。可以用“初始化列表”方法实现数组的初始化。",
        "tags": [
            "一维数组",
            "初始化",
            "概念"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00064",
        "title": "一维数组的初始化",
        "content": "(1) 在定义数组时对全部数组元素赋予初值。例如：```c\nint a[10]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n```将数组中各元素的初值顺序放在一对花括号内，数据间用逗号分隔。花括号内的数据就称为“初始化列表”。经过上面的定义和初始化之后，`a[0]=0, a[1]=1, a[2]=2, a[3]=3, a[4]=4, a[5]=5, a[6]=6, a[7]=7, a[8]=8, a[9]=9`。\n(2) 可以只给数组中的一部分元素赋值。例如：```c\nint a[10]={0, 1, 2, 3, 4};\n```定义`a`数组有10个元素，但花括号内只提供5个初值，这表示只给前面5个元素赋初值，系统自动给后5个元素赋初值为0。\n(3) 如果想使一个数组中全部元素值为0，可以写成```c\nint a[10]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n```或```c\nint a[10]={0}; //未赋值的部分元素自动设定为0\n```\n(4) 在对全部数组元素赋初值时，由于数据的个数已经确定，因此可以不指定数组长度。例如：```c\nint a[5]={1, 2, 3, 4, 5};\n```可以写成```c\nint a[]={1, 2, 3, 4, 5};\n```在第2种写法中，花括号中有5个数，虽然没有在方括号中指定数组的长度，但是系统会根据花括号中数据的个数确定`a`数组有5个元素。但是，如果数组长度与提供初值的个数不相同，则方括号中的数组长度不能省略。例如，想定义数组长度为10，就不能省略数组长度的定义，而必须写成“`int a[10]={1, 2, 3, 4, 5};`”，只初始化前5个元素，后5个元素为0。",
        "tags": [
            "一维数组",
            "初始化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00065",
        "title": "不同类型数组元素默认的初始化行为",
        "content": "如果在定义数值型数组时，指定了数组的长度并对之初始化，凡未被“初始化列表”指定初始化的数组元素，系统会自动把它们初始化为0；如果是字符型数组，则初始化为'0'；如果是指针型数组，则初始化为`NULL`，即空指针。",
        "tags": [
            "数值型数组",
            "字符型数组",
            "指针型数组",
            "初始化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00066",
        "title": "二维数组的定义",
        "content": "二维数组常称为矩阵(matrix)。把二维数组写成行(row)和列(column)的排列形式，可以有助于形象化地理解二维数组的逻辑结构。其基本概念与方法和一维数组相似。如：`float pay[3][6];`定义了一个float型的二维数组，第1维有3个元素，第2维有6个元素。每一维的长度分别用一对方括号括起来。二维数组定义的一般形式为`类型说明符 数组名[常量表达式][常量表达式]`，例如：`float a[3][4], b[5][10];`定义`a`为3行4列的数组，`b`为5行10列的数组。注意，不能写成`float a[3, 4], b[5, 10]; ／／在一对方括号内写两个下标，错误`C语言对二维数组采用这样的定义方式，使得二维数组可被看作一种特殊的一维数组：它的元素又是一个一维数组。例如，可以把`a`看作一个一维数组，它有3个元素：`a[0], a[1], a[2]`，每个元素又是一个包含4个元素的一维数组。可以把`a[0], a[1], a[2]`看作3个一维数组的名字。上面定义的二维数组可以理解为定义了3个一维数组，即相当于把`a[0], a[1], a[2]`看作一维数组名。C语言的这种处理方法在数组初始化和用指针表示时显得很方便，这在以后会体会到。",
        "tags": [
            "二维数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00067",
        "title": "二维数组的存放方式",
        "content": "C语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第1行的元素， 接着再存放第2行的元素。假设数组a存放在从2000字节开始的一段内存单元中，一个元素占4个字节，前16个字节(2000~2015)存放序号为0的行中的4个元素，接着的16个字节(2016~2031)存放序号为1的行中的4个元素，余类推。注意：用矩阵形式（如3行4列形式）表示二维数组，是逻辑上的概念，能形象地表示出行列关系。而在内存中，各元素是连续存放的，不是二维的，是线性的。",
        "tags": [
            "二维数组",
            "存放"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00068",
        "title": "怎样引用二维数组的元素",
        "content": "二维数组元素的表示形式为`数组名[下标][下标]`。例如，`a[2][3]`表示`a`数组中序号为2的行中序号为3的列的元素。下标应是整型表达式，如`a[2-1][2*2-1]`。不要写成`a[2, 3]`、`a[2-1, 2*2-1]`形式。数组元素可以出现在表达式中，也可以被赋值，例如：`b[1][2]=a[2][3]/2`。在引用数组元素时，下标值应在已定义的数组大小的范围内。在这个问题上常出现错误。例如：```c\nint a[3][4]; //定义a为3*4的二维数组\n``````c\na[3][4]=3; //不存在a[3][4]元素\n```按以上的定义，数组`a`可用的“行下标”的范围为`0~2`，“列下标”的范围为`0~3`。用a[3][4]表示元素显然超过了数组的范围。",
        "tags": [
            "二维数组",
            "引用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00069",
        "title": "定义数组和引用数组元素的区别",
        "content": "请严格区分在定义数组时用的`a[3][4]`和引用元素时的`a[3][4]`的区别。前者用`a[3][4]`来定义数组的维数和各维的大小，后者`a[3][4]`中的`3`和`4`是数组元素的下标值，`a[3][4]`代表行序号为`3`、列序号为`4`的元素（行序号和列序号均从`0`起算）。",
        "tags": [
            "定义数组",
            "引用元素"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00070",
        "title": "二维数组的初始化",
        "content": "可以用“初始化列表”对二维数组初始化。\n(1) 分行给二维数组赋初值。例如：`int a[3][4]={{1, 2, 3, 4},{5, 6, 7, 8},{9, 10, 11, 12}};`这种赋初值方法比较直观，把第1个花括号内的数据给第1行的元素，第2个花括号内的数据赋给第2行的元素等，即按行赋初值。\n(2) 可以将所有数据写在一个花括号内，按数组元素在内存中的排列顺序对各元素赋初值。例如：`int a[3][4]={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};`效果与前相同。但以第(1)种方法为好，一行对一行，界限清楚。用第(2)种方法如果数据多，则会写成一大片，容易遗漏，也不易检查。\n(3) 可以对部分元素赋初值。例如：`int a[3][4]={{1},m{5}, {9}};`它的作用是只对各行第1列（即序号为`0`的列）的元素赋初值，其余元素值自动为0；也可以对各行中的某一元素赋初值，例如：`int a[3][4]={{1}, {0, 6}, {0, 0, 11}};`这种方法对非0元素少时比较方便，不必将所有的0都写出来，只须输入少量数据。也可以只对某几行元素赋初值：`int a[3][11]={{1}, {5, 6}};`，即第3行不赋初值；`int a[3][4]={{1}, {}, {9}};`，即第2行不赋初值。\n(4) 如果对全部元素都赋初值（即提供全部初始数据），则定义数组时对第1维的长度可以不指定，但第2维的长度不能省。例如：```c\nint a[3][4]={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n```与下面的定义等价：```c\nint a[][4]={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n```系统会根据数据总个数和第2维的长度算出第1维的长度。数组一共有12个元素，每行4列，显然可以确定行数为3。在定义时也可以只对部分元素赋初值而省略第1维的长度，但应分行赋初值。例如：`int a[][4] ={{0, 0, 3}, 1}, {0, 10}};`这样的写法，能通知编译系统；数组共有3行。",
        "tags": [
            "二维数组",
            "初始化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00071",
        "title": "怎样定义字符数组",
        "content": "用来存放字符数据的数组是字符数组，在字符数组中的一个元素内存放一个字符。定义字符数组的方法与定义数值型数组的方法类似。例如：```c\nchar c[10];\nc[0]='I'; c[1]=''; c[2]='a'; c[3]='m'; c[4]=''; c[S]='h'; c[6]='a'; c[7]='p'; c[8]='p'; c[9]='y';\n```以上定义了`c`为字符数组，包含10个元素。由于字符型数据是以整数形式（ASCII代码）存放的，因此也可以用整型数组来存放字符数据，例如：```c\nint c[19];\nc[0]='a'; //合法，但浪费存储空间```",
        "tags": [
            "字符数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00072",
        "title": "字符数组的初始化",
        "content": "对字符数组初始化，最容易理解的方式是用“初始化列表”，把各个字符依次赋给数组中各元素。例如：`char c[10]={'I', ' ', 'a', 'm', ' ','h', 'a', 'p', 'p', 'y'};`把10个字符依次赋给`c[0]~c[9]`这10个元素。如果在定义字符数组时不进行初始化，则数组中各元素的值是不可预料的。如果花括号中提供的初值个数（即字符个数）大于数组长度，则出现语法错误。如果初值个数小于数组长度，则只将这些字符赋给数组中前面那些元素，其余的元素自动定为空字符（即`'\\0'`）。例如：`char c[1O]= {'c', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm'};`。如果提供的初值个数与预定的数组长度相同，在定义时可以省略数组长度，系统会自动根据初值个数确定数组长度。例如：`char c[]={'I', ' ', 'a', 'm', ' ','h', 'a', 'p', 'p', 'y'};`数组`c`的长度自动定为10。用这种方式可以不必人工去数字符的个数，尤其在赋初值的字符个数较多时，比较方便。也可以定义和初始化一个二维字符数组，例如：`char diamond[5][5]={{' ', ' ', '*'}, {' ', '*', ' ', '*'}, {'*', ' ', ' ', ' ', '*'}, {' ', '*', ' ', '*'}, {' ', ' ', '*'}};`用它代表一个菱形的平面图形。",
        "tags": [
            "字符数组",
            "初始化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00073",
        "title": "字符串结束标志是什么？",
        "content": "C语言规定了一个“字符串结束标志”，以字符`'\\0'` 作为结束标志。如果字符数组中存有若干字符，前面9个字符都不是空字符(`'\\0'`) ，而第10个字符是`'\\0'`，则认为数组中有一个字符串，其有效字符为9个。也就是说，在遇到字符`'\\0'` 时，表示字符串结束，把它前面的字符组成一个字符串。`'\\0'`代表ASCII码为0的字符，从ASCII码表中可以查到，ASCII码为0的字符不是一个可以显示的字符，而是一个“空操作符”，即它什么也不做。用它来作为字符串结束标志不会产生附加的操作或增加有效字符，只起一个供辨别的标志。",
        "tags": [
            "字符串",
            "结束标志"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00074",
        "title": "字符数组的输入输出方式",
        "content": "字符数组的输入输出可以有两种方法。\n(1) 逐个字符输入输出。用格式符\"%c\"输入或输出一个字符。\n(2) 将整个字符串一次输入或输出。用\"%s\"格式符，意思是对字符串(string)的输入输出。输出时，遇结束符`'\\0'`就停止输出。",
        "tags": [
            "字符数组",
            "输入",
            "输出"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00075",
        "title": "输出字符串的函数`puts函数`的定义以及作用",
        "content": "其一般形式为`puts (字符数组)`，其作用是将一个字符串（以`'\\0'`结束的字符序列）输出到终端。假如已定义`str`是一个字符数组名，且该数组已被初始化为“China”。则执行：`puts(str);`，其结果是在终端上输出“China”。由于可以用`printf函数`输出字符串，因此puts函数用得不多。另外，用puts函数输出的字符串中可以包含转义字符。例如：```c\nchar str[]= {\"China\nBeijing\"};\nputs(str);\n```，其输出为：\nChina\nBeijing\n在用puts输出时将字符串结束标志`'\\0'`转换成'\\n'，即输出完字符串后换行。",
        "tags": [
            "`puts函数`",
            "定义",
            "作用",
            "字符串输出"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00076",
        "title": "输入字符串的函数`gets函数`的定义以及作用",
        "content": "其一般形式为`gets (字符数组)`，其作用是从终端输入一个字符串到字符数组，并且得到一个函数值。该函数值是字符数组的起始地址。一般利用`gets函数`的目的是向字符数组输入一个字符串，而不大关心其函数值。",
        "tags": [
            "`gets函数`",
            "定义",
            "作用",
            "字符串输入"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00077",
        "title": "用`puts函数`和`gets函数`能否输出或输入多个字符串？",
        "content": "不能，用`puts函数`和`gets函数`只能输出或输入一个字符串，不能写成`puts(strl, str2);`或`gets(strl, str2);`。",
        "tags": [
            "`puts函数`",
            "`gets函数`",
            "字符串输出",
            "字符串输入"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00078",
        "title": "字符串连接函数`strcat函数`的定义以及作用",
        "content": "其一般形式为`strcat(字符数组1, 字符数组2)`，strcat是STRing CATenate（字符串连接）的缩写。其作用是把两个字符数组中的字符串连接起来，把字符串2接到字符串1的后面，结果放在字符数组1中，函数调用后得到一个函数值，即字符数组1的地址。字符数组1必须足够大，以便容纳连接后的新字符串。连接前两个字符串的后面都有`'\\0'`， 连接时将宇符串1后面的`'\\0'`取消，只在新串最后保留`'\\0'`。",
        "tags": [
            "`strcat函数`",
            "定义",
            "作用",
            "字符串连接"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00079",
        "title": "字符串复制函数`strcpy函数`(或`strncpy函数`)的定义以及作用",
        "content": "其一般形式为`strcpy(字符数组1, 字符串2)`，strcpy是STRingCoPY（字符串复制）的简写。它表示“字符串复制函数”，作用是将字符串2复制到字符数组1中去。strncpy与上述同理。字符数组1 必须定义得足够大，以便容纳被复制的宇符串2。字符数组1的长度不应小于字符串2的长度。“字符数组1”必须写成数组名形式(如str1)，“字符串2”可以是字符数组名，也可以是一个字符串常量。",
        "tags": [
            "`strcpy函数`",
            "`strncpy函数`",
            "定义",
            "作用",
            "字符串复制"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00080",
        "title": "如果在复制前未对`str1`数组初始化或赋值，则复制后`str1`各字节中的内容如何？",
        "content": "如果在复制前未对`str1`数组初始化或赋值，则复制后`str1`各字节中的内容是无法预知的，复制时将`str2`中的字符串和其后的`'\\0'`一起复制到字符数组1中，取代字符数组1中的前面6个字符，最后4个字符并不一定是`'\\0'`，而是`str1`中原有的最后4个字节的内容。",
        "tags": [
            "字符串复制",
            "初始化",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00081",
        "title": "能否用赋值语句将一个字符串常量或字符数组直接给一个字符数组？",
        "content": "不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组。字符数组名是一个地址常量，它不能改变值，正如数值型数组名不能被赋值一样。只能用`strcpy函数`将一个字符串复制到另一个字符数组中去。用赋值语句只能将一个宇符赋给一个字符型变量或宇符数组元素。",
        "tags": [
            "赋值语句",
            "字符串常量",
            "字符数组"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00082",
        "title": "是否能用`strncpy函数`将字符串2中前面n个字符复制到字符数组1中去？",
        "content": "可以用`strncpy函数`将字符串2中前面n个字符复制到字符数组1中去。例如：`strncpy(str1,str2,2);`作用是将`str2`中最前面2个字符复制到`str1`中，取代`str1`中原有的最前面2个字符。但复制的字符个数n不应多于`str1`中原有的字符（不包括`'\\0'`)。",
        "tags": [
            "`strncpy函数`",
            "字符串复制",
            "`strcpy函数`"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00083",
        "title": "字符串比较函数`strcmp函数`的定义以及作用",
        "content": "其一般形式为`strcmp (字符串1, 字符串2)`，`strcmp`是`STRing CoMPare（字符串比较）`的缩写。它的作用是比较字符串1和字符串2。字符串比较的规则是：将两个字符串自左至右逐个字符相比（按ASCII码值大小比较），直到出现不同的字符或遇到`'\\0'`为止。\n(1) 如全部字符相同，则认为两个字符串相等；\n(2) 若出现不相同的字符，则以第1对不相同的字符的比较结果为准。\n比较的结果由函数值带回。\n(1) 如果字符串1与字符串2相同，则函数值为0。\n(2) 如果字符串l大于字符串2，则函数值为一个正整数。\n(3) 如果字符串l小于字符串2，则函数值为一个负整数。",
        "tags": [
            "`strcmp函数`",
            "定义",
            "作用",
            "字符串比较"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00084",
        "title": "测字符串长度的函数`strlen函数`的定义以及作用",
        "content": "其一般形式为`strlen (字符数组)`，strlen是STRing LENgth（字符串长度）的缩写。它是测试字符串长度的函数，也可以直接测试字符串常量的长度。函数的值为字符串中的实际长度（不包括'\\0' 在内）。",
        "tags": [
            "测字符串长度",
            "`strlen函数`",
            "定义",
            "作用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00085",
        "title": "转换为小写的函数`strlwr函数`的定义以及作用",
        "content": "其一般形式为`strlwr (字符串)`，strlwr是STRing LoWeRcase（ 字符串小写）的缩写。函数的作用是将字符串中大写字母换成小写字母。",
        "tags": [
            "`strlwr函数`",
            "定义",
            "作用",
            "转换为小写"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00086",
        "title": "转换为大写的函数`strupr函数`的定义以及作用",
        "content": "其一般形式为`strupr (字符串)`，strupr是STRing UPpeRcase（字符串大写）的缩写。函数的作用是将字符串中小写字母换成大写字母。",
        "tags": [
            "`strupr函数`",
            "定义",
            "作用",
            "转换为大写"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00087",
        "title": "什么是函数",
        "content": "函数就是功能。每一个函数用来实现一个特定的功能。函数的名宇应反映其代表的功能。",
        "tags": [
            "函数",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00088",
        "title": "C程序的模块化与源文件组织",
        "content": "一个C程序由一个或多个程序模块组成，每一个程序模块作为一个源程序文件。对较大的程序，一般不希望把所有内容全放在一个文件中，而是将它们分别放在若干个源文件中，由若干个源程序文件组成一个C程序。这样便于分别编写和编译，提高调试效率。一个源程序文件可以为多个C程序共用。",
        "tags": [
            "程序模块",
            "源文件",
            "代码组织"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00089",
        "title": "C程序的执行从何处开始？",
        "content": "C程序的执行是从`main函数`开始的。如果在main函数中调用其他函数，在调用后流程返回到`main函数`，在`main函数`中结束整个程序的运行。",
        "tags": [
            "main函数",
            "C程序的执行"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00090",
        "title": "源程序文件是什么？",
        "content": "一个源程序文件由一个或多个函数以及其他有关内容（如指令、数据声明与定义等）组成。一个源程序文件是一个编译单位，在程序编译时是以源程序文件为单位进行编译的，而不是以函数为单位进行编译的。",
        "tags": [
            "源程序文件",
            "编译单位"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00091",
        "title": "各个函数之间的关系？",
        "content": "所有函数都是平行的，即在定义函数时是分别进行的，是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。函数间可以互相调用，但不能调用`main函数`。`main函数`是被操作系统调用的。",
        "tags": [
            "函数的调用",
            "关系"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00092",
        "title": "从用户使用的角度看，函数有哪些类型？",
        "content": "从用户使用的角度看，函数有两种。\n(1) 库函数。它是由系统提供的，用户不必自己定义，可直接使用它们。应该说明，不同的C语言编译系统提供的库函数的数量和功能会有一些不同。当然许多基本的函数是共同的。\n(2) 用户自己定义的函数。它是用以解决用户专门需要的函数。",
        "tags": [
            "用户使用",
            "函数类型",
            "库函数",
            "用户自己定义的函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00093",
        "title": "从函数的形式看，函数有哪些类型？",
        "content": "从函数的形式看，函数分两类。\n(1) 无参函数。在调用无参函数时，主调函数不向被调用函数传递数据。无参函数一般用未执行指定的一组操作。无参函数可以带回或不带回函数值，但一般以不带回函数值的居多。\n(2) 有参函数。在调用函数时，主调函数在调用被调用函数时，通过参数向被调用函数传递数据，一般情况下，执行被调用函数时会得到一个函数值，供主调函数使用。",
        "tags": [
            "函数的形式",
            "函数类型",
            "无参函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00094",
        "title": "为什么要定义函数？",
        "content": "C语言要求，在程序中用到的所有函数，必须“先定义，后使用”。例如想用`max函数`去求两个数中的大者，必须事先按规范对它进行定义，指定它的名字、函数返回值类型、函数实现的功能以及参数的个数与类型，将这些信息通知编译系统。这样，在程序执行`max`时，编译系统就会按照定义时所指定的功能执行。",
        "tags": [
            "函数",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00095",
        "title": "怎么定义无参函数？",
        "content": "无参函数的函数名后面的括号中是空的，没有任何参数。定义无参函数的一般形式为```c\n类型名 函数名()\n{\n  函数体\n}\n```或\n```c\n类型名 函数名(void)\n{\n  函数体\n}\n```函数名后面括号内的void表示“空”，即函数没有参数。函数体包括声明部分和语句部分。在定义函数时要用“类型标识符”（即类型名）指定函数值的类型，即指定函数带回来的值的类型。",
        "tags": [
            "无参函数",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00096",
        "title": "怎么定义有参函数？",
        "content": "定义有参函数的一般形式为```c\n类型名 函数名(形式参数表列)\n{\n  函数体\n}\n```函数体包括声明部分和语句部分。",
        "tags": [
            "有参函数",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00097",
        "title": "怎么定义空函数以及为什么要定义空函数？",
        "content": "其形式为```c\n类型名 函数名()\n{ }\n```例如：```c\nvoid dummy( )\n{ }\n```函数体是空的。调用此函数时，什么工作也不做，没有任何实际作用。在主调函数中如果有调用此函数的语句：`dummy();`表明“要调用`dummy函数`”，而现在这个函数没有起作用。那么为什么要定义一个空函数呢？在程序设计中往往根据需要确定若干个模块，分别由一些函数来实现。而在第1阶段只设计最基本的模块，其他一些次要功能或锦上添花的功能则在以后需要时陆续补上。在编写程序的开始阶段，可以在将来准备扩充功能的地方写上一个空函数（函数名取将来采用的实际函数名（如用merge(), matproduct(), concatenate() 和shell( )等，分别代表合并、矩阵相乘、字符串连接和希尔法排序等），只是这些函数暂时还未编写好，先用空函数占一个位置，等以后扩充程序功能时用一个编好的函数代替它。这样做，程序的结构清楚，可读性好，以后扩充新功能方便，对程序结构影响不大。空函数在程序设计中常常是有用的。",
        "tags": [
            "空函数",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00098",
        "title": "函数调用的一般形式",
        "content": "函数调用的一般形式为`函数名 (实参表列)`，如果是调用无参函数，则“实参表列”可以没有，但括号不能省略。如果实参表列包含多个实参，则各参数间用逗号隔开。",
        "tags": [
            "函数调用",
            "一般形式"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00099",
        "title": "按函数调用在程序中出现的形式和位置来分，有哪些函数调用方式？",
        "content": "按函数调用在程序中出现的形式和位置来分，可以有以下3种函数调用方式。\n1. 函数调用语句：把函数调用单独作为一个语句。这时不要求函数带回值，只要求函数完成一定的操作。\n2. 函数表达式：函数调用出现在另一个表达式中，如“`c=max(a, b);`”，`max(a, b)`是一次函数调用，它是赋值表达式中的一部分。这时要求函数带回一个确定的值以参加表达式的运算。例如：`c=2*max(a,b);`\n3. 函数参数:函数调用作为另一个函数调用时的实参。例如：`m=max(a, max(b, c));`其中，`max(b, c)`是一次函数调用，它的值是`b`和`c`二者中的“大者”，把它作为`max`另一次调用的实参。经过赋值后，`m`的值是`a`,`b`,`c`三者中的最大者。",
        "tags": [
            "函数调用方式",
            "形式和位置"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00100",
        "title": "什么是形式参数和实际参数？",
        "content": "在调用有参函数时，主调函数和被调用函数之间有数据传递关系。在定义函数时函数名后面括号中的变量名称为”形式参数”（简称“形参”)或“虚拟参数”。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”（简称“实参”)。实际参数可以是常量、变量或表达式。",
        "tags": [
            "形式参数",
            "实际参数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00101",
        "title": "什么是实参和形参间的数据传递？",
        "content": "在调用函数过程中，系统会把实参的值传递给被调用函数的形参。或者说，形参从实参得到一个值。该值在函数调用期间有效，可以参加该函数中的运算。在调用函数过程中发生的实参与形参间的数据传递称为“虚实结合”。",
        "tags": [
            "形式参数",
            "实际参数",
            "数据传递"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00102",
        "title": "实参向形参的数据传递是单向传递还是双向传递？",
        "content": "实参向形参的数据传递是“值传递”，单向传递，只能由实参传给形参，而不能由形参传给实参。实参和形参在内存中占有不同的存储单元，实参无法得到形参的值。",
        "tags": [
            "形式参数",
            "实际参数",
            "数据传递",
            "单向传递"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00103",
        "title": "什么是函数的返回值？",
        "content": "通常，希望通过函数调用使主调函数能得到一个确定的值，这就是函数值（函数的返回值）。",
        "tags": [
            "函数",
            "返回值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00104",
        "title": "函数的返回值是通过函数中的什么语句获得？",
        "content": "函数的返回值是通过函数中的`return语句`获得的。`return语句`将被调用函数中的一个确定值带回到主调函数中去。如果需要从被调用函数带回一个函数值（供主调函数使用），被调用函数中必须包含`return语句`。如果不需要从被调用函数带回函数值可以不要`return语句`。一个函数中可以有一个以上的`return语句`，执行到哪一个`return语句`，哪一个`return语句`就起作用。`return语句`后面的括号可以不要，如“`return z;`”与“`return (z);`”等价。`return`后面的值可以是一个表达式。",
        "tags": [
            "返回值",
            "`return语句`"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00105",
        "title": "是否要在定义函数时要指定函数值的类型？",
        "content": "是，既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。",
        "tags": [
            "返回值",
            "类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00106",
        "title": "C语言中函数类型与返回值类型的匹配规则",
        "content": "在定义函数时指定的函数类型一般应该和`return语句`中的表达式类型一致。如果函数值的类型和`return语句`中表达式的值不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。",
        "tags": [
            "函数",
            "类型匹配",
            "返回值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00107",
        "title": "对于不带回值的函数，应当定义函数何种类型？",
        "content": "对于不带回值的函数，应当定义函数为“void类型”（或称“空类型”)。这样，系统就保证不使函数带回任何值，即禁止在调用函数中使用被调用函数的返回值。此时在函数体中不得出现`return语句`。",
        "tags": [
            "不带回值的函数",
            "void类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00108",
        "title": "在一个函数中调用另一个函数（即被调用函数）需要具备什么条件",
        "content": "在一个函数中调用另一个函数（即被调用函数）需要具备如下条件：\n(1) 首先被调用的函数必须是已经定义的函数（是库函数或用户自己定义的函数）。但仅有这一条件还不够。\n(2) 如果使用库函数，应该在本文件开头用#include指令将调用有关库函数时所需用到的信息“包含”到本文件中来。\n(3) 如果使用用户自己定义的函数，而该函数的位置在调用它的函数（即主调函数）的后面（在同一个文件中），应该在主调函数中对被调用的函数作声明(declaration)。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。",
        "tags": [
            "调用函数",
            "条件"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00109",
        "title": "函数声明的一般形式有哪些？",
        "content": "函数声明的一般形式有两种，分别为\n(1) `函数类型 函数名（参数类型1 参数名1, 参数类型2 参数名2, ···,参数类型n 参数名n);`\n(2) `函数类型 函数名（参数类型1, 参数类型2, ···, 参数类型n);`",
        "tags": [
            "函数声明",
            "一般形式"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00110",
        "title": "对函数的“定义”和“声明”有什么不同？",
        "content": "对函数的“定义”和“声明”不是同一回事。函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位。而函数的声明的作用则是把函数的名宇、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查（例如，函数名是否正确，实参与形参的类型和个数是否一致），它不包含函数体。",
        "tags": [
            "函数定义",
            "函数声明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00111",
        "title": "函数能否嵌套定义或调用？",
        "content": "C语言的函数定义是互相平行、独立的，也就是说，在定义函数时，一个函数内不能再定义另一个函数，即不能嵌套定义，但可以嵌套调用函数，即在调用一个函数的过程中，又调用另一个函数。",
        "tags": [
            "函数",
            "嵌套定义",
            "嵌套调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00112",
        "title": "什么是函数的递归调用？",
        "content": "在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用。C语言的特点之一就在于允许函数的递归调用。",
        "tags": [
            "函数",
            "递归调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00113",
        "title": "数组元素可以用作函数实参或形参吗？",
        "content": "数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配存储单元的，不可能为一个数组元素单独分配存储单元（数组是一个整体，在内存中占连续的一段存储单元） 。",
        "tags": [
            "数组",
            "函数实参",
            "函数形参"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00114",
        "title": "C语言中数组作为函数参数的值传递机制是什么？",
        "content": "在用数组元素作函数实参时，把实参的值传给形参，是“值传递”方式。数据传递的方向是从实参传到形参，单向传递。",
        "tags": [
            "函数参数",
            "数组",
            "值传递"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00115",
        "title": "用数组元素和数组名做函数实参时，向形参变量传递分别是什么？",
        "content": "用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数实参时，向形参（数组名或指针变量）传递的是数组首元素的地址。",
        "tags": [
            "数组元素",
            "数组名",
            "函数实参",
            "形参变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00116",
        "title": "多维数组名作函数参数",
        "content": "可以用多维数组名作为函数的实参和形参，在被调用函数中对形参数组定义时可以指定每一维的大小，也可以省略第一维的大小说明。但是不能把第2维以及其他高维的大小说明省略。这是为什么呢？前已说明，二维数组是由若干个一维数组组成的。在内存中，数组是按行存放的，因此．在定义二维数组时，必须指定列数（即一行中包含几个元素） ， 由于形参数组与实参数组类型相同，所以它们是由具有相同长度的一维数组所组成的。不能只指定第1维（行数）而省略第2维（列数）。C语言编译系统不检查第一维的大小。在学习指针以后，对此会有更深入的认识。",
        "tags": [
            "多维数组名",
            "函数参数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00117",
        "title": "定义变量的可能位置有哪些？",
        "content": "定义变量可能有3种情况：\n(1) 在函数的开头定义；\n(2) 在函数内的复合语句内定义；\n(3) 在函数的外部定义。",
        "tags": [
            "定义变量",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00118",
        "title": "什么是局部变量？",
        "content": "在一个函数内部定义的变量只在本函数范围内有效。也就是说只有在本函数内才能引用它们，在此函数以外是不能使用这些变量的。在复合语句内定义的变量只在本复合语句范围内有效，只有在本复合语句内才能引用它们。在该复合语句以外是不能使用这些变量的，以上这些称为“局部变量” 。",
        "tags": [
            "局部变量",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00119",
        "title": "主函数中定义的变量在整个文件或程序中有效吗？",
        "content": "主函数中定义的变量也只在主函数中有效，并不因为在主函数中定义而在整个文件或程序中有效。主函数也不能使用其他函数中定义的变量。",
        "tags": [
            "主函数",
            "定义变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00120",
        "title": "不同函数中可以使用同名的变量吗？",
        "content": "不同函数中可以使用同名的变量，它们代表不同的对象，互不干扰。",
        "tags": [
            "函数",
            "同名变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00121",
        "title": "什么是“分程序”或“程序块”？",
        "content": "在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序”或“程序块”。",
        "tags": [
            "分程序",
            "程序块",
            "函数",
            "复合语句"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00122",
        "title": "什么是全局变量？",
        "content": "程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量称为外部变量，外部变量是全局变量（也称全程变量）。全局变量可以为本文件中其他函数所共用。它的有效范围为从定义变址的位置开始到本源文件结束。",
        "tags": [
            "全局变量",
            "外部变量",
            "局部变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00123",
        "title": "设置全局变量的作用是什么？",
        "content": "设置全局变量的作用是增加了函数间数据联系的渠道。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其他函数中全局变量的值。相当于各个函数间有直接的传递通道。由于函数的调用只能带回一个函数返回值，因此有时可以利用全局变量来增加函数间的联系渠道，通过函数调用能得到一个以上的值。",
        "tags": [
            "全局变量",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00124",
        "title": "建议不在必要时不要使用全局变量，原因有哪些？",
        "content": "建议不在必要时不要使用全局变量，原因如下：\n(1) 全局变量在程序的全部执行过程中都占用存储单元。而不是仅在需要时才开辟单元。\n(2) 它使函数的通用性降低了，因为如果在函数中引用了全局变量，那么执行情况会受到有关的外部变量的影响，如果将一个函数移到另一个文件中，还要考虑把有关的外部变量及其值一起移过去。但是若该外部变量与其他文件的变量同名时，就会出现问题。这就降低了程序的可靠性和通用性。在程序设计中，在划分模块时要求模块的“内聚性”强、与其他模块的“耦合性”弱。即模块的功能要单一（不要把许多互不相干的功能放到一个模块中）。与其他模块的相互影响要尽量少，而用全局变量是不符合这个原则的。一般要求把C程序中的函数做成一个相对的封闭体，除了可以通过“实参——形参”的渠道与外界发生联系外没有其他渠道。这样的程序移植性好，可读性强。\n(3) 使用全局变量过多，会降低程序的清晰性。人们往往难以清楚地判断出每个瞬时各个外部变量的值。由于在各个函数执行时都可能改变外部变量的值，程序容易出错。因此，要限制使用全局变量。",
        "tags": [
            "全局变量",
            "原因"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00125",
        "title": "从变量的作用域（即从空间）的角度来观察，变量可以分为什么？",
        "content": "从变量的作用域（即从空间）的角度来观察，变量可以分为全局变量和局部变量。",
        "tags": [
            "全局变量",
            "局部变量",
            "变量的作用域"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00126",
        "title": "从变量值存在的时间（即生存期）来观察，变量的存储有哪些方式？",
        "content": "从变量值存在的时间（即生存期）来观察，有的变量在程序运行的整个过程都是存在的，而有的变量则是在调用其所在的函数时才临时分配存储单元，而在函数调用结束后该存储单元就马上释放了，变量不存在了。也就是说，变量的存储有两种不同的方式：静态存储方式和动态存储方式。静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式，而动态存储方式则是在程序运行期间根据需要进行动态的分配存储空间的方式。",
        "tags": [
            "全局变量",
            "局部变量",
            "变量的作用域"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00127",
        "title": "内存中的供用户使用的存储空间可以分为哪些部分？",
        "content": "这个存储空间可以分为3部分：\n(1) 程序区；\n(2) 静态存储区；\n(3) 动态存储区。\n数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变扯分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。",
        "tags": [
            "内存",
            "存储空间"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00128",
        "title": "在动态存储区中存放何种数据？",
        "content": "在动态存储区中存放以下数据：\n(1) 函数形式参数。在调用函数时给形参分配存储空间。\n(2)函数中定义的没有用关键字static声明的变量，即自动变量。\n(3) 函数调用时的现场保护和返回地址等。\n对于以上这些数据，在函数调用开始时分配动态存储空间，函数结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的，如果在一个程序中两次调用同一函数，而在此函数中定义局部变量，在两次调用时分配给这些局部变量的存储空间的地址可能是不相同的。",
        "tags": [
            "动态存储区",
            "数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00129",
        "title": "每一个变量和函数都有两个属性，是指什么？",
        "content": "在C语言中，每一个变量和函数都有两个属性：数据类型和数据的存储类别。对数据类型，我们已经熟知（如整型、浮点型等）。存储类别指的是数据在内存中存储的方式（如静态存储和动态存储）。在定义和声明变量和函数时，一般应同时指定其数据类型和存储类别，也可以采用默认方式指定（即如果用户不指定，系统会隐含地指定为某一种存储类别）。",
        "tags": [
            "变量",
            "函数",
            "属性"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00130",
        "title": "C的存储类别有哪些？",
        "content": "C的存储类别包括4种：自动的(auto)、静态的(statis)、寄存器的(register)、外部的(extern)。根据变量的存储类别，可以知道变量的作用域和生存期。",
        "tags": [
            "存储类别",
            "变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00131",
        "title": "什么是自动变量？",
        "content": "函数中的局部变量，如果不专门声明为static（静态）存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间。因此这类局部变显称为自动变量。自动变量用关键字auto作存储类别的声明。实际上，关键字auto可以省略，不写auto则隐含指定为“自动存储类别”，它属于动态存储方式。程序中大多数变量属于自动变量。",
        "tags": [
            "自动变量",
            "动态"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00132",
        "title": "什么是静态局部变量（static局部变量）？",
        "content": "有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值（就是上一次函数调用结束时的值）。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。",
        "tags": [
            "静态局部变量",
            "static局部变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00133",
        "title": "静态局部变量和自动变量的区别？",
        "content": "(1) 静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整个运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，分配在动态存储区空间而不在静态存储区空间，函数调用结束后即释放。\n(2)对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句。\n(3) 如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符'\\0'（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可知的。",
        "tags": [
            "静态局部变量",
            "自动变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00134",
        "title": "3种局部变量的存储位置分别是什么？",
        "content": "3种局部变量的存储位置是不同的：自动变量存储在动态存储区；静态局部变量存储在静态存储区；寄存器存储在CPU中的寄存器中。",
        "tags": [
            "局部变量",
            "自动变量",
            "静态局部变量",
            "寄存器存储"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00135",
        "title": "什么是寄存器变量（register变量）？",
        "content": "一般情况下，变量（包括静态存储方式和动态存储方式）的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。如果有一些变量使用频繁（例如，在一个函数中执行10000次循环，每次循环中都要引用某局部变量），则为存取变量的值要花费不少时间。为提高执行效率，允许将局部变量的值放在CPU中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量叫做寄存器变量，用关键字register作声明。由于现在的计算机的速度愈来愈快，性能愈来愈高，优化的编译系统能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，现在实际上用register声明变量的必要性不大。在此不详细介绍它的使用方法和有关规定，读者只需要知道有这种变量即可，以便在阅读他人写的程序时遇到register时不会感到困惑。",
        "tags": [
            "寄存器变量",
            "register变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00136",
        "title": "C语言中外部变量的作用域及其扩展",
        "content": "一般来说，外部变量是在函数的外部定义的全局变量，它的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为程序中各个函数所引用。但有时程序设计人员希望能扩展外部变量的作用域。有以下几种情况。\n1. 在一个文件内扩展外部变量的作用域；\n2. 将外部变量的作用域扩展到其他文件；\n3. 将外部变量的作用域限制在本文件中。",
        "tags": [
            "外部变量",
            "作用域",
            "全局变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00137",
        "title": "在一个文件内扩展外部变量的作用域",
        "content": "如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字extern对该变量作“外部变量声明”，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从“声明”处起，合法地使用该外部变量。",
        "tags": [
            "外部变量",
            "作用域",
            "声明",
            "extern"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00138",
        "title": "将外部变量的作用域扩展到其他文件",
        "content": "如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量`Num`，不能分别在两个文件中各自定义一个外部变量`Num`，否则在进行程序的连接时会出现“重复定义”的错误。正确的做法是：在任一个文件中定义外部变量`Num`，而在另一文件中用extern对`Num`作“外部变量声明”，即“`extern Num;`”。在编译和连接时，系统会由此知道`Num`有“外部链接”，可以从别处找到已定义的外部变量`Num`，并将在另一文件中定义的外部变量`Num`的作用域扩展到本文件，在本文件中可以合法地引用外部变量`Num`。",
        "tags": [
            "外部变量",
            "作用域",
            "多文件编程",
            "extern"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00139",
        "title": "将外部变量的作用域限制在本文件中",
        "content": "有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其他文件引用。这时可以在定义外部变量时加一个static声明。这种加上static声明、只能用于本文件的外部变量称为静态外部变量。在程序设计中，常由若干人分别完成各个模块，各人可以独立地在其设计的文件中使用相同的外部变量名而互不相干。只需在每个文件中定义外部变量时加上static即可。这就为程序的模块化、通用性提供方便。如果已确认其他文件不需要引用本文件的外部变量，就可以对本文件中的外部变量都加上static，成为静态外部变量，以免被其他文件误用。这就相当于把本文件的外部变量对外界“屏蔽”起来，从其他文件的角度看，这个静态外部变量是“看不见，不能用”的。至于在各文件中在函数内定义的局部变量，本来就不能被函数外引用，更不能被其他文件引用，因此是安全的。不要误认为对外部变量加static声明后才采取静态存储方式（存放在静态存储区中），而不加static的是采取动态存储（存放在动态存储区）。声明局部变量的存储类型和声明全局变量的存储类型的含义是不同的。对于局部变量来说，声明存储类型的作用是指定变量存储的区域（静态存储区或动态存储区）以及由此产生的生存期的问题，而对于全局变量来说，由于都是在编译时分配内存的，都存放在静态存储区，声明存储类型的作用是变量作用域的扩展问题。",
        "tags": [
            "外部变量",
            "作用域",
            "static",
            "存储类型",
            "模块化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00140",
        "title": "使用static声明变量的效果与作用域",
        "content": "使用static声明一个变量的作用是：\n(1) 对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在。\n(2) 对全局变量用static声明，则该变量的作用域只限于本文件模块（即被声明的文件中）。",
        "tags": [
            "static声明",
            "变量作用域",
            "存储类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00141",
        "title": "变量的作用域与可见性及生存期的概念",
        "content": "如果一个变量在某个文件或函数范围内是有效的，就称该范围为该变量的作用域，在此作用域内可以引用该变量，在专业书籍中称变量在此作用域内‘可见’，这种性质称为变量的可见性。如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的生存期，或称该变量在此时刻‘存在’。",
        "tags": [
            "变量作用域",
            "变量可见性",
            "生存期"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00142",
        "title": "static关键字对局部变量和全局变量的不同影响",
        "content": "static对局部变量和全局变量的作用不同。对局部变量来说，它使变量由动态存储方式改变为静态存储方式。而对全局变量来说，它使变量局部化（局部于本文件），但仍为静态存储方式。从作用域角度看，凡有static声明的，其作用域都是局限的，或者局限于本函数内（静态局部变量），或者局限于本文件内（静态外部变量）。",
        "tags": [
            "static关键字",
            "局部变量",
            "全局变量",
            "存储方式",
            "作用域"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00143",
        "title": "声明与定义的区别及作用",
        "content": "在声明部分出现的变量有两种情况：一种是需要建立存储空间的（如“`int a;`”），另一种是不需要建立存储空间的（如“`extern a;`”）。前者称为定义性声明（defining declaration），或简称定义；后者称为引用性声明（referencing declaration）。广义地说，声明包括定义，但并非所有的声明都是定义。对“`int a;`”而言，它既是声明，又是定义；而对“`extern a;`”而言，它是声明而不是定义。一般为了叙述方便，把建立存储空间的声明称为定义，而把不需要建立存储空间的声明称为声明。显然这里指的声明是狭义的，即非定义性声明。有一个简单的结论，在函数中出现的对变量的声明（除了用extern声明的以外）都是定义。在函数中对其他函数的声明不是函数的定义。",
        "tags": [
            "声明",
            "定义",
            "extern",
            "变量声明",
            "函数声明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00144",
        "title": "内部函数与外部函数的区分及其调用范围",
        "content": "有的函数可以被本文件中的其他函数调用，也可以被其他文件中的函数调用，而有的函数只能被本文件中的其他函数调用，不能被其他文件中的函数调用。函数本质上是全局的，因为定义一个函数的目的就是要被另外的函数调用。如果不加声明的话，一个文件中的函数既可以被本文件中其他函数调用，也可以被其他文件中的函数调用。但是，也可以指定某些函数不能被其他文件调用。根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。",
        "tags": [
            "函数",
            "内部函数",
            "外部函数",
            "调用范围"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00145",
        "title": "内部函数的定义与使用",
        "content": "如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加static，即：`static 类型名 函数名(形参表);`。例如，函数的首行：`static int fun(int a, int b)`表示`fun`是一个内部函数，不能被其他文件调用。内部函数又称静态函数，因为它是用static声明的。使用内部函数，可以使函数的作用域只局限于所在文件。这样，在不同的文件中即使有同名的内部函数，也互不干扰，不必担心所用函数是否会与其他文件模块中的函数同名。通常把只能由本文件使用的函数和外部变量放在文件的开头，前面都冠以static使之局部化，其他文件不能引用。这就提高了程序的可靠性。",
        "tags": [
            "内部函数",
            "静态函数",
            "函数作用域",
            "static关键字"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00146",
        "title": "外函数的定义与跨文件调用",
        "content": "如果在定义函数时，在函数首部的最左端加关键字extern，则此函数是外部函数，可被其他文件调用。如函数首部可以为：`extern int fun(int a, int b);`。这样，函数`fun`就可以被其他文件调用。C语言规定，如果在定义函数时省略`extern`，则默认为外部函数。本书前面所用的函数都是外部函数。在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型进行声明）。在对此函数作声明时，要加关键字extern，表示该函数“是在其他文件中定义的外部函数”。",
        "tags": [
            "外部函数",
            "extern关键字",
            "函数声明",
            "跨文件调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00147",
        "title": "变量在内存中的存储与指针概念的引入",
        "content": "为了说清楚什么是指针，必须先弄清楚数据在内存中是如何存储的，又是如何读取的。如果在程序中定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据程序中定义的变量类型，分配一定长度的空间。例如，Visual C++为整型变量分配4个字节，为单精度浮点型变量分配4个字节，为字符型变量分配1个字节。内存区的每一个字节有一个编号，这就是“地址”，它相当于旅馆中的房间号。在地址所标志的内存单元中存放的数据则相当于旅馆房间中居住的旅客。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。打个比方，一个房间的门口挂了一个房间号2008，这个2008就是房间的地址，或者说，2008“指向”该房间。因此，将地址形象化地称为“指针”。意思是通过它能找到以它为地址的内存单元。",
        "tags": [
            "内存管理",
            "变量存储",
            "指针概念",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00148",
        "title": "存储单元地址与内容的区别及变量访问机制",
        "content": "请务必弄清楚存储单元的地址和存储单元的内容这两个概念的区别。假设程序已定义了3个整型变量`i`, `j`, `k`，在程序编译时，系统可能分配地址为2000-2003的4个字节给变量i，2004-2007的4个字节给j，2008-2011的4个字节给k（不同的编译系统在不同次的编译中，分配给变量的存储单元的地址是不相同的）。在程序中一般是通过变量名来引用变量的值，例如：`printf(\"%d\n\", i);`，由于在编译时，系统已为变量`i`分配了按整型存储方式的4个字节，并建立了变量名和地址的对应表，因此在执行上面语句时，首先通过变量名找到相应的地址，从该4个字节中按照整型数据的存储方式读出整型变量`i`的值，然后按十进制整数格式输出。",
        "tags": [
            "内存管理",
            "存储单元",
            "地址",
            "变量访问"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00149",
        "title": "直接访问与间接访问变量的方式",
        "content": "对变量的访问都是通过地址进行的。假如有输入语句`scanf(\"%d\", &i);`，在执行时，把键盘输入的值送到地址为2000开始的整型存储单元中。如果有语句`k=i+j;`，则从2000~2003字节取出`i`的值（比如3），再从2004~2007字节取出`j`的值（比如6），将它们相加后再将其和（比如9）送到k所占用的2008~2011字节单元中。这种直接按变量名进行的访问，称为‘直接访问’方式。还可以采用另一种称为‘间接访问’的方式，即将变量`i`的地址存放在另一变量中，然后通过该变量来找到变量`i`的地址，从而访问`i`变量。",
        "tags": [
            "变量访问",
            "直接访问",
            "间接访问",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00150",
        "title": "指向的概念与指针的定义",
        "content": "指向就是通过地址来体现的。假设`i_pointer`中的值是变量i的地址(2000)，这样就在`i_pointer`和变量`i`之间建立起一种联系，即通过`i_pointer`能知道`i`的地址，从而找到变量`i`的内存单元。由于通过地址能找到所需的变量单元，因此说，地址指向该变量单元（如同说，一个房间号“指向”某一房间一样）。将地址形象化地称为“指针”。意思是通过它能找到以它为地址的内存单元（如同根据地址2000就能找到变量`i`的存储单元一样）。",
        "tags": [
            "指针",
            "地址",
            "指向"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00151",
        "title": "指针变量的定义",
        "content": "如果有一个变量专门用来存放另一个变量的地址（即指针），则它称为“指针变量”。指针变量就是地址变量，用来存放地址，指针变量的值是地址（即指针）。定义指针变量的一般形式为：`类型名 * 指针变量名；`，如`int * pointer_1, *pointer_2;`，左端的`int`是在定义指针变量时必须指定的“基类型”。指针变量的基类型用来指定此指针变量可以指向的变量的类型。",
        "tags": [
            "指针变量",
            "地址变量",
            "基类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00152",
        "title": "指针与指针变量的区别",
        "content": "区分“指针”和“指针变量”这两个概念：例如，可以说变量i的指针是2000，而不能说i的指针变量是2000。指针是一个地址，而指针变量是存放地址的变量。",
        "tags": [
            "指针",
            "指针变量",
            "区别"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00153",
        "title": "一个变量的指针的含义是什么？",
        "content": "一个变量的指针的含义包括两个方面：一是以存储单元编号表示的纯地址（如编号为2000的字节），一是它指向的存储单元的数据类型（如int, char, float等）。",
        "tags": [
            "指针",
            "数据类型",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00154",
        "title": "指针变量类型的完整说明",
        "content": "在说明变量类型时不能一般地说‘a是一个指针变量’，而应完整地说：‘a是指向整型数据的指针变量，b是指向单精度型数据的指针变量，c是指向字符型数据的指针变量’。",
        "tags": [
            "指针变量",
            "类型说明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00155",
        "title": "指针类型的表示方法",
        "content": "指向整型数据的指针类型表示为“`int *`”，读作“指向int的指针”或简称“int指针”。可以有`int *`, `char *`, `float*`等指针类型（`int *`, `float *`, `char *`是3种不同的类型，不能混淆）。",
        "tags": [
            "指针类型",
            "表示方法"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00156",
        "title": "引用指针变量的三种情况",
        "content": "在引用指针变量时，可能有3种情况：\n(1) 给指针变量赋值。\n(2) 引用指针变量指向的变量。\n(3) 引用指针变量的值。",
        "tags": [
            "指针变量",
            "引用",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00157",
        "title": "指针作为函数参数的使用",
        "content": "函数的参数不仅可以是整型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。不能企图通过改变指针形参的值而使指针实参的值改变。函数的调用可以（而且只可以）得到一个返回值（即函数值），而使用指针变量作参数，可以得到多个变化了的值。如果不用指针变量是难以做到这一点的。",
        "tags": [
            "函数参数",
            "指针",
            "返回值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00158",
        "title": "利用指针法的技巧",
        "content": "要善于利用指针法，特别是在需要从函数调用中获取多个结果或需要修改函数外部变量的情况下。",
        "tags": [
            "指针",
            "函数调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00159",
        "title": "什么是数组元素的指针？",
        "content": "一个数组包含若干元素，每个数组元素都在内存中占用存储单元，它们都有相应的地址。指针变量既然可以指向变量，当然也可以指向数组元素（把某一元素的地址放到一个指针变量中）。所谓数组元素的指针就是数组元素的地址。",
        "tags": [
            "指针",
            "数组元素",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00160",
        "title": "引用数组元素的方法",
        "content": "引用数组元素可以用下标法（如`a[3]`），也可以用指针法，即通过指向数组元素的指针找到所需的元素。使用指针法能使目标程序质量高（占内存少，运行速度快）。",
        "tags": [
            "数组元素",
            "引用",
            "下标法",
            "指针法"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00161",
        "title": "数组名与首元素地址的关系",
        "content": "在C语言中，数组名（不包括形参数组名）代表数组中首元素（即序号为0的元素）的地址。程序中的数组名不代表整个数组，只代表数组首元素的地址。",
        "tags": [
            "数组名",
            "首元素",
            "地址",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00162",
        "title": "指针操作与数组元素的关联",
        "content": "当一个指针变量已经指向数组中的一个元素时，可以对该指针进行以下运算：\n1. 加一个整数（使用`+`或`+=`），如`p+1`；\n2. 减一个整数（使用`-`或`-=`），如`p-1`；\n3. 自增运算，如`p++`, `++p`；\n4. 自减运算，如`p--`, `--p`。\n5.两个指针相减，如`p1-p2`，仅当`p1`和`p2`都指向同一数组中的元素时才有意义。\n分别详细说明如下：1. 指针加1或减1的操作并不意味着简单地将指针的值（地址）增加或减少1，而是增加或减少一个数组元素所占用的字节数。例如，如果数组元素是`float`型，每个元素占据4个字节，那么`p+1`意味着使指针的值（地址）增加4个字节，以指向下一个元素。因此，`p+1`实际上等于`p+1 * sizeof(float)`。\n2. 如果指针`p`最初指向`a[0]`，那么`p+i`和`a+i`就代表数组元素`a[i]`的地址，或者说，它们指向`a`数组中索引为`i`的元素。这里的`a`代表数组首元素的地址，而`a+1`的计算方式与`p+1`相同，即它的实际地址为`a+1 * sizeof(element_type)`。\n3. `*(p+i)`或`*(a+i)`是`p+i`或`a+i`所指向的数组元素，即`a[i]`。例如，`*(p+5)`或`*(a+5)`就是`a[5]`。也就是说，`*(p+5)`, `*(a+5)`和`a[5]`三者等价。\n4. 如果指针变量`p1`和`p2`都指向同一数组中的元素，如执行`p2-p1`，结果是`p2`和`p1`的值（两个地址之差）除以数组元素的长度。例如，如果`p2`指向实型数组元素`a[5]`，`p2`的值为2020；`p1`指向`a[3]`，其值为2012，那么`p2-p1`的结果是`(2020-2012) / sizeof(float)`，即2。这表示`p2`所指的元素与`p1`所指的元素之间相差2个元素。但需注意：两个地址不能相加，如`p1+p2`是没有实际意义的。",
        "tags": [
            "指针",
            "数组",
            "指针运算",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00163",
        "title": "数组元素的引用方法",
        "content": "引用一个数组元素，可以使用以下两种方法：\n1. **下标法**，如`a[i]`形式；\n2. **指针法**，如`*(a+i)`或`*(p+i)`。其中`a`是数组名，`p`是指向数组元素的指针变量，其初值`p=a;`。\n这两种方法在逻辑上等价，都用于访问数组中的特定元素。使用指针法有时可以提供更灵活的数组操作。",
        "tags": [
            "数组",
            "引用",
            "下标法",
            "指针法"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00164",
        "title": "函数调用的值传递机制",
        "content": "C语言调用函数时虚实结合的方法都是采用“值传递”方式，当用变量名作为函数参数时传递的是变量的值，当用数组名作为函数参数时，由于数组名代表的是数组首元素地址，因此传递的值是地址。",
        "tags": [
            "函数调用",
            "值传递",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00165",
        "title": "形参为指针变量的原因",
        "content": "当用数组名作为函数实参时，由于数组名实质上传递的是地址，因此要求形参为指针变量，以便能够接收并处理这个地址。",
        "tags": [
            "函数参数",
            "指针变量",
            "数组名",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00166",
        "title": "使用形参数组形式的原因",
        "content": "在用数组名作为函数实参时，尽管形参实质上是指针变量，仍然允许使用形参数组的形式。这是因为C语言中下标法和指针法都可以访问一个数组，下标法表示更为直观，便于理解，因此许多人倾向于使用数组名作形参，以便与实参数组对应。",
        "tags": [
            "形参数组",
            "下标法",
            "指针法",
            "数组访问"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00167",
        "title": "形参数组与实参数组的关系",
        "content": "从应用角度看，用户可以认为有一个形参数组，它从实参数组那里得到起始地址，因此形参数组与实参数组共占同一段内存单元，在调用函数期间，如果改变了形参数组的值，也就是改变了实参数组的值。这意味着在主调函数中就可以利用这些已改变的值。",
        "tags": [
            "形参数组",
            "实参数组",
            "内存单元",
            "函数调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00168",
        "title": "实参与形参的地址特性",
        "content": "实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。",
        "tags": [
            "实参数组",
            "形参数组",
            "地址特性",
            "指针常量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义/概念/用法"
        },
        "id": "00169",
        "title": "数组名作为函数参数及指针变量的应用",
        "content": "一维数组名可以作为函数参数，多维数组名同样可以作为函数参数。当使用指针变量作为形参，以接受实参数组名传递过来的地址时，可以采用两种方法：\n1. 使用指向变量的指针变量**；\n2. 使用指向一维数组的指针变量。\n这两种方法使得函数能够操作传入的数组，无论是一维还是多维，通过指针变量间接访问数组元素。",
        "tags": [
            "函数参数",
            "指针变量",
            "一维数组",
            "多维数组"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00170",
        "title": "字符串是存放在什么数据类型当中的？",
        "content": "在C程序中，字符串是存放在字符数组当中的。",
        "tags": [
            "字符串",
            "字符数组",
            "存储"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00171",
        "title": "如何引用一个字符串？",
        "content": "想引用一个字符串,可以用以下两种方法：\n（1）用字符数组存放一个字符串，可以通过数组名和下标引用字符串中一个字符，也可以通过数组名和格式声明“%s”输出该字符串。\n（2）用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。",
        "tags": [
            "字符串",
            "引用",
            "数组",
            "下标",
            "指针变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00172",
        "title": "数组名代表数组中哪个元素的地址？",
        "content": "数组名代表数组首元素的地址。",
        "tags": [
            "数组",
            "存储",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00173",
        "title": "对字符指针变量进行初始化时对其赋了什么值？",
        "content": "对字符指针变量初始化，实际上是把字符串第一个元素的地址赋给该指针变量。",
        "tags": [
            "初始化",
            "赋值",
            "指针变量",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00174",
        "title": "能否将字符串赋给字符指针变量？",
        "content": "不能。字符指针变量只能指向一个字符类型数据，而不能同时指向多个字符数据。从而不能将字符串赋给字符指针变量，只能将字符串的第一个字符的地址赋给字符指针变量。",
        "tags": [
            "指针变量",
            "字符串",
            "赋值",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00175",
        "title": "数值型数组能否用数组名输出它的全部元素？",
        "content": "不能。通过字符数组名或字符指针变量可以输出一个字符串，但对于一个数值型数组，是不能用数组名输出它的全部元素的，只能逐个输出。",
        "tags": [
            "数值型数组",
            "输出",
            "指针变量",
            "数组名"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00176",
        "title": "改变字符指针变量的值后，能否再通过该指针变量引用原先的字符串？",
        "content": "不能。改变字符指针变量的值后，指针会指向新字符串的第一个字符，不再指向原字符串的第一个字符了，因此不能再通过指针引用原先的字符串了。",
        "tags": [
            "赋值",
            "指针变量",
            "字符串",
            "引用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00177",
        "title": "如何用字符指针变量输出它所指向的字符串？",
        "content": "可以通过字符指针变量输出它所指向的字符串，如：\n```c\nprintf(\"%s\n\",string);\n```\n%s是输出字符串时所用的格式符，在输出项中给出字符指针变量名string，则系统会输出string所指向的字符串第1个字符，然后自动使string加1，使之指向下一个字符。再输出该字符……如此直到遇到字符串结束标志'\\0'为止。注意，在内存中，字符串的最后被自动加了一个'\\0'，因此在输出时能确定输出的字符到何时结束。可以看到用%s可以对一个字符串进行整体的输入输出。",
        "tags": [
            "指针变量",
            "字符串",
            "输出"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00178",
        "title": "如何利用指针在函数间传递字符串？",
        "content": "如果想把一个字符串从一个函数“传递”到另一个函数，可以用地址传递的办法，即用字符数组名作参数，也可以用字符指针变量作参数。在被调用的函数中可以改变字符串的内容，在主调函数中可以引用改变后的字符串。",
        "tags": [
            "指针变量",
            "字符串",
            "地址",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00179",
        "title": "字符数组和字符指针变量有什么区别？",
        "content": "（1）字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第1个字符的地址），绝不是将字符串放到字符指针变量中。\n（2）赋值方式不同。可以对字符指针变量赋值，但不能对数组名赋值。\n（3）初始化的含义不同。定义字符指针变量a时，是把字符串第一个元素的地址赋给a。而数组可以在定义时对各元素赋初值，但不能用赋值语句对字符数组中全部元素整体赋值。\n（4）存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。\n（5）指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。\n（6）字符数组中各元素的值是可以改变的（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容是不可以被取代的（不能对它们再赋值）。\n（7）引用数组元素的方法不同。对字符数组可以用下标法（用数组名和下标）引用一个数组元素（如a[5]），也可以用地址法（如*(a+5)）引用数组元素 a[5]。如果定义了字符指针变量p，并使它指向数组a的首元素，则可以用指针变量带下标的形式引用数组元素（如p[5]）。同样，可以用地址法（如*(p+5)）引用数组元素a[5]。\n（8）用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。因此只要改变指针变量format所指向的字符串，就可以改变输人输出的格式。这种printf函数称为可变格式输出函数。但使用字符数组时，只能采用在定义数组时初始化或逐个对元素赋值的方法，而不能用赋值语句对数组整体赋值。",
        "tags": [
            "字符数组",
            "字符指针变量",
            "赋值",
            "存储",
            "输入输出",
            "数组元素",
            "引用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00180",
        "title": "定义了字符数组，但未赋值，其值是什么？",
        "content": "如果定义了字符数组，但未对它赋值，这时数组中的元素的值是不可预料的。可以引用（如输出）这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和改正。",
        "tags": [
            "字符数组",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00181",
        "title": "定义了字符指针，但未赋值，会导致什么后果？",
        "content": "如果定义了字符指针变量，应当及时把一个字符变量（或字符数组元素）的地址赋给它使它指向一个字符型数据。如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量所指向的对象输人数据，可能会出现严重的后果。常有人用下面的方法：\n\n```c\nchar *a; //定义字符指针变量a\nscanf(\"%s\",a); //企图从键盘输入一个字符串，使a指向该字符串，错误\n```\n\n在 Visual C++中编译时会发出“警告”信息，提醒未给指针变量指定初始值（未指定其指向），虽然也能勉强运行，但这种方法是危险的。因为编译时给指针变量a分配了存储单元，变量a的地址（即&a）是已指定了，但a并未被赋值，在a的存储单元中是一个不可预料的值。在执行scanf函数时，要求将一个字符串输入到a所指向的一段存储单元（即以a的值（是一个地址）开始的一段内存单元）中。而a的值如今却是不可预料的，它可能指向内存中空白的（未用的）用户存储区中（这是好的情况），也有可能指向已存放指令或数据的有用内存段，这就会破坏了程序或有用数据，甚至破坏了系统，会造成严重的后果。应当绝对防止这种情况的出现。应当在定义指针变量后，及时指定其指向。如：\n\n```c\nchar *a,str[10]; //定义了字符指针变量a和字符数组str\na=str; //使a指向str数组的首元素\nscanf(\"%s\",a); //从键盘输入一个字符串存放到a所指向的一段存储单元中，正确\n```\n\n先使a有确定值，使a指向一个数组元素，然后输入一个字符串，把它存放在以该地址开始的若干单元中。",
        "tags": [
            "字符指针",
            "初始化",
            "赋值",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00182",
        "title": "什么是函数的指针？",
        "content": "如果在程序中定义了一个函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段内存空间有一个起始地址，也称为函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。函数名代表函数的起始地址。调用函数时，从函数名得到函数的起始地址，并执行函数代码。\n函数名就是函数的指针，它代表函数的起始地址。\n可以定义一个指向函数的指针变量，用来存放某一函数的起始地址，这就意味着此指针变量指向该函数。例如：\n\n```c\nint (*p)(int,int);\n```\n\n定义p是一个指向函数的指针变量，它可以指向函数类型为整型且有两个整型参数的函数此时，指针变量p的类型用int (*)(int,int)表示。",
        "tags": [
            "函数指针",
            "函数名",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00183",
        "title": "如何调用一个函数？",
        "content": "如果想调用一个函数，除了可以用函数名调用以外，还可以通过指向函数的指针变量来调用该函数。用两种方法实现函数的调用，结果是一样的。但使用函数名调用函数，只能调用所制定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数。",
        "tags": [
            "函数指针",
            "函数名",
            "函数调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00184",
        "title": "函数指针变量是指向函数中的第一个指令吗？",
        "content": "不是。函数指针变量只能指向函数的入口处而不可能指向函数中间的某一条指令处，因此也不能用*(指针变量名+1)来表示函数的下一条指令。",
        "tags": [
            "函数指针",
            "函数名",
            "函数调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00185",
        "title": "怎样定义指向函数的指针变量？",
        "content": "定义指向函数的指针变量的一般形式为__类型名__ __(*指针变量名)(函数参数表列)__。如\n\n```c\nint (*p)(int int);\n```\n\n这里的类型名是指函数返回值的类型。",
        "tags": [
            "函数指针",
            "定义",
            "类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00186",
        "title": "怎样判定指针变量是指向函数的指针变量呢？",
        "content": "首先看变量名的前面有无*号，如*P。如果有。肯定是指针变量而不是普通变量。其次，看变量名的后面有无圆括号，内有形参的类型。如果有，就是指向函数的指针变量，这对圆括号是函数的特征。要注意的是：由于优先级的关系，“*指针变量名”要用圆括号括起来。",
        "tags": [
            "函数指针",
            "形式"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00187",
        "title": "函数指针可以指向什么类型的函数？",
        "content": "定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。如\n\n```c\nint (*p)(int,int);\n```\n\n表示指针变量p可以指向函数返回值为整型且有两个整型参数的函数。在程序中把哪一个符合类型的函数的地址赋给它，它就指向哪一个函数。在一个程序中，一个指针变量可以先后指向类型不同的函数。",
        "tags": [
            "函数指针",
            "定义",
            "类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00188",
        "title": "用指针调用函数前需要使指针变量指向什么值？",
        "content": "如果要用指针调用函数，必须先使指针变量指向该函数。",
        "tags": [
            "函数指针",
            "调用",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00189",
        "title": "如何给函数指针变量赋值？",
        "content": "在给函数指针变量赋值时，只须给出函数名而不必给出参数。因为是将函数入口地址赋给指针变量，而不涉及实参与形参的结合问题。如：\n\n```c\np=max;\n```\n\n如果写成\n\n```c\np=max(a,b);\n```\n\n则是将调用max函数所得到的函数值赋给p，而不是将函数入口地址赋给p。",
        "tags": [
            "函数指针",
            "赋值",
            "函数名",
            "参数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00190",
        "title": "如何给函数指针变量调用函数？",
        "content": "用函数指针变量调用函数时，只须将(*p)代替函数名即可（p为指针变量名），在(*p)之后的括号中根据需要写上实参。例如：\n\n```c\nc=(*p)(a,b);\n```\n\n表示调用由p指向的函数，实参为a和b，得到的函数值赋给c。需要注意函数返回值的类型需要与变量c的类型保持一致。",
        "tags": [
            "函数指针",
            "函数调用",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00191",
        "title": "函数指针变量能否进行算术运算？",
        "content": "对指向函数的指针变量不能进行算术运算，如p+n，p++，p--等运算是无意义的。",
        "tags": [
            "函数指针",
            "算术运算"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00192",
        "title": "如何利用函数指针变量把函数的入口地址作为参数传递到其他函数？",
        "content": "函数指针变量可以作为函数参数，把函数的入口地址传递给形参，这样就能够在被调用的函数中使用实参函数。它的原理可以简述如下：有一个函数（假设函数名为fun），它有两个形参（x1和x2），定义x1和x2为指针变量。在调用函数fun时，实参为两个函数名f1和f2，给形参传递的是f1和f2的入口地址。这样在函数fun中就可以调用f1和f2函数了。例如：\n\n```c\nvoid fun(int (*x1)(int),int (*x2)(int,int)) //定义fun函数，形参是指向函数的指针变量\n  {int a,b,i=3,j=5;\n   a=(*x1)(i); //调用f1函数，i是实参\n   b=(*x2)(i,j); //调用f2函数，i，j是实参\n  }\n```\n\n在fun函数中声明形参x1和x2为指向函数的指针变量，x1指向的函数有一个整型形参，x2指向的函数有两个整型形参。i和j是调用f1和f2函数时所要求的实参。函数fun的形参x1和x2（指针变量）在函数fun未被调用时并不占内存单元，也不指向任何函数。在主函数调用fun函数时，把实参f1和f2的入口地址传给形参指针变量x1和x2，使x1和x2指向函数f1和f2。这时，在函数fun中，用*x1和*x2就可以调用函数f1和f2。(*x1)(i)就相当于f1(i)，(*x2)(i,j)就相当于f2(i,j)。",
        "tags": [
            "函数指针",
            "函数调用",
            "实参",
            "形参",
            "函数入口",
            "传递"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00193",
        "title": "如何定义一个返回指针值的函数？",
        "content": "定义返回指针值的函数的原型的一般形式为__类型名__ __*函数名(参数表列);__。例如：\n\n```c\nint *a(int x,int y);\n```\n\n其中a是函数名，调用它以后能得到一个指向整型数据的指针，即整型数据是地址。x和y是a的形参，为整型。需要注意的是，*a的两侧没有括号，在a的两侧分别是*运算符和()运算符。而()优先级高于*，因此a先与()结合，显然这是函数形式。该函数前面有一个*，表示此函数是指针型函数（函数值是指针），最前面的int表示返回的指针指向整型变量。",
        "tags": [
            "函数定义",
            "返回值",
            "指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00194",
        "title": "什么是指针数组？",
        "content": "一个数组，若其元素均为指针类型的数据，称为指针数组。也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。",
        "tags": [
            "指针变量",
            "指针数组"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00195",
        "title": "如何正确定义一个指针数组？",
        "content": "定义一维指针数组的一般形式为__类型名__ __*数组名[数组长度];__。类型名中应包含符号*，例如int *表示指向整型数据的指针类型。因此，可以利用下面的语句来定义一个指针数组：\n\n```c\nint *p[4];\n```\n\n由于[]比*优先级高，因此p与[4]先结合，形成p[4]形式，这显然是数组形式，表示p数组有四个元素。然后再与p前面的*结合，*表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都可指向一个整型变量。注意不要写成\n\n```c\nint (*p)[4]; //这是指向一维数组的指针变量\n```\n\n",
        "tags": [
            "指针数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00196",
        "title": "什么情况下会用到指针数组？",
        "content": "指针数组比较适合用来指向若干个字符串，使字符串处理更加方便灵活。例如，图书馆有若干本书，想把书名放在一个数组中，然后要对这些书目进行排序和查询。按一般方法，字符串本身就是一个字符数组。因此要设计一个二维的字符数组才能存放多个字符串。但在定义二维数组时，需要指定列数，也就是说二维数组中每一行中包含的元素个数（即列数）相等。而实际上各字符串（书名）长度一般是不相等的。如按最长的字符串来定义列数，则会浪费许多内存单元。\n事实上，可以分别定义一些字符串，然后用指针数组中的元素分别指向各字符串。如果想对字符串排序，不必改动字符串的位置，只须改动指针数组中各元素的指向（即改变各元素的值，这些值是各字符串的首地址）。这样，各字符串的长度可以不同，而且移动指针变量的值（地址）要比移动字符串所花的时间少得多。",
        "tags": [
            "指针数组",
            "用途",
            "字符数组",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00197",
        "title": "什么叫做把指针数组中某两个元素的指向互换？",
        "content": "例如，将指针数组中下标为i和k的两个元素对换，也就是将指向第i个字符串的数组元素（是指针型元素）的值与指向第k个字符串的数组元素的值对换，也就是把它们的指向互换。",
        "tags": [
            "指针数组",
            "地址",
            "指向"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00198",
        "title": "什么是指向指针的指针？",
        "content": "指向指针数据的指针变量，简称为指向指针的指针。定义一个指针数组name，它的每一个元素是一个指针型的变量，其值为地址。同时，name作为一个数组，它的每一个元素都应有相应的地址。数组名name代表该指针数组首元素的地址。name+i是name[i]的地址，也就是指向指针型数据的指针。还可以设置一个指针变量p，它指向指针数组的元素，此时p就是指向指针型数据的指针变量。",
        "tags": [
            "指针变量",
            "指向指针的指针",
            "指针数组",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00199",
        "title": "怎样定义一个指向指针数据的指针变量？",
        "content": "定义一个指向指针数据的指针变量：\n\n```c\nchar **p;\n```\n\np的前面有两个*号，由于*运算符的结合性是从右到左，因此**p相当于*(*p)。显然*p是指针变量的定义形式，如果没有最前面的*号，那就是定义了一个指向字符数据的指针变量。现在它前面又有一个*号，即char **p。可以把它分成两部分看，即：char *和(*p)。也就是说，p指向一个字符型指针变量（这个字符指针变量指向一个字符型数据）。如果引用*p，就得到p所指向的字符指针变量的值。设name是一个指针数组，如果有：\n\n```c\np=name+2;\nprintf(\"%d\\n\",*p);\nprintf(\"%s\\n\",*p);\n```\n\n第1个printf函数语句输出name[2]的值（它是一个地址），第2个printf函数语句以字符串形式（%s）输出name[2]所指向的字符串。",
        "tags": [
            "指针数组",
            "地址",
            "指向"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00200",
        "title": "指针数组的元素可以存放哪种数据类型？",
        "content": "指针数组的元素只能存放地址，不能存放整数。下面的语句就是错误的：\n\n```c\nint *num[5]={1,3,5,7,9}\n```\n\n",
        "tags": [
            "指针数组",
            "地址",
            "数据类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00201",
        "title": "什么是间址？",
        "content": "利用指针变量访问另一个变量就是“间接访问”。如果在一个指针变量中存放一个目标变量的地址，这就是__单级间址__。指向指针数据的指针用的是__二级间址__方法。从理论上说，间址方法可以延伸到更多的级，即多重指针，但在实际程序中很少有超过二级间址的。级数越多，越难理解，容易产生混乱，出错机会也多。",
        "tags": [
            "间址",
            "多重指针",
            "间接访问"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00202",
        "title": "调用main函数需不需要给出实参？",
        "content": "一般程序中，main函数的第一行通常写成以下形式：\n\n```c\nint main()\n```\n\n或\n\n```c\nint main(void)\n```\n\n这代表main函数没有参数，调用main函数时也不必给出实参。但在某些情况下，main函数也可以有参数。",
        "tags": [
            "main函数",
            "参数",
            "调用"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00203",
        "title": "如何定义一个有参数的main函数？",
        "content": "定义一个有参数的main函数的形式如下：\n\n```c\nint main(int argc,char *argv[])\n```\n\n其中argc和argv就是main函数的形参，它们是程序的“命令行参数”。argc（argument count）意思是参数个数，argv（argument vector）意思是参数向量。argv是一个*char指针数组，数组中的每一个元素（其值为指针）指向命令行中的一个字符串的首字母。\n注意，如果用带参数的main函数，其第一个形参必须是int型，用来接收形参个数，第二个形参必须是字符串指针数组，用来接收从操作系统命令行传来字符串中首字符的地址。",
        "tags": [
            "main函数",
            "参数",
            "形参",
            "定义",
            "指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00204",
        "title": "main函数是如何被调用的？",
        "content": "通常main函数和其他函数组成一个文件模块，有一个文件名。对这个文件进行编译和连接，得到可执行文件（后缀为.exe）。用户执行这个可执行文件，操作系统就调用main函数，然后由main函数调用其他函数，从而完成程序的功能。",
        "tags": [
            "main函数",
            "调用",
            "操作系统"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00205",
        "title": "main函数的形参是从哪里传递给它们的呢？",
        "content": "main函数是操作系统调用的，实参只能由操作系统给出。在操作命令状态下，实参是和执行文件的命令一起给出的。例如在DOS，UNIX或Linux等系统的操作命令状态下，在命令行中包括了命令名和需要传递给main函数的参数。\n命令行的一般形式为__命令名__ __参数1__ __参数2…参数n__。命令名和各参数之间用空格分割。命令名是可执行的文件名（此文件包含main函数），假设可执行文件名为file1.exe，今想将两个字符串\"China\"，\"Beijing\"作为传递给main函数的参数，则命令行可以写成以下形式：\n\n    file1 China Beijing\n\nfile1为可执行文件名，China和Beijing是调用main函数时的实参。命令行参数必须都是字符串，这些字符串的首地址构成一个指针数组传递给main函数。在本例中，argc的值为3（\"file1\"也算一个参数）。",
        "tags": [
            "main函数",
            "参数",
            "命令行",
            "操作系统",
            "文件"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00206",
        "title": "利用指针数组作为main函数的形参有什么优点？",
        "content": "利用指针数组作main函数的形参，可以向程序传送命令行参数（这些参数是字符串），这些字符串的长度事先并不知道，而且各字符串的长度一般并不相同，命令行参数的数目也可以是任意的。用指针数组能够较好地满足上述需求。",
        "tags": [
            "main函数",
            "参数",
            "指针数组",
            "命令行"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00207",
        "title": "什么是内存的动态分配？",
        "content": "全局变量是分配在内存中的静态存储区的，非静态的局部变量（包括形参）是分配在内存中的动态存储区的，这个存储区是一个称为栈（stack）的区域。除此以外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据。这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆（heap）区。可以根据需要，向系统申请所需大小的空间。由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。",
        "tags": [
            "内存",
            "分配",
            "堆",
            "栈",
            "动态存储区"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00208",
        "title": "怎样建立内存动态分配？",
        "content": "对内存的动态分配是通过系统提供的库函数来实现的，主要有malloc、calloc、free、realloc这4个函数。\n1. 用malloc函数开辟动态存储区\n其函数原型为\n\n```c\nvoid *malloc(unsigned int size);\n```\n\n其作用是在内存的动态存储区中分配一个长度为size的连续空间。形参size的类型定为无符号整型（不允许为负数）。此函数的值（即“返回值”）是所分配区域的第一个字节的地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的第一个字节。如：\n\n```c\nmalloc(100); //开辟100字节的临时分配域,数值为其第1个字节的地址\n```\n\n注意指针的基类型为void，即不指向任何类型的数据，只提供一个纯地址。如果此函数未能成功地执行（例如内存空间不足）则返回空指针（NULL）。\n2. 用calloc函数开辟动态存储区\n其函数原型为\n\n```c\nvoid *calloc(unsigned n,unsigned size);\n```\n\n其作用是在内存的动态存储区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组。\n用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是动态数组。函数返回指向所分配域的第一个字节的指针；如果分配不成功，返回NULL。如：\n\n```c\np=calloc(50,4); //开辟50×4个字节的临时分配域，把首地址赋给指针变量P\n```\n\n3. 用realloc函数重新分配动态存储区\n其函数原型为\n\n```c\nvoid *realloc(void *p,unsigned int size);\n```\n\n如果已经通过malloc函数或calloc函数获得了动态空间，想改变其大小，可以用recalloc函数重新分配。\n用realloc函数将p所指向的动态空间的大小改变为size。p的值不变。如果重分配不成功，返回NULL。如\n\n```c\nrealloc(p,50); //将p所指向的已分配的动态空间改为50字节\n```\n\n4. 用free函数释放动态存储区\n其函数原型为\n\n```c\nvoid free(void *p);\n```\n\n其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的数返回值。如：\n\n```c\nfree( p); //释放指针变量P所指向的已分配的动态空间\n```\n\nfree函数无返回值。\n以上4个函数的声明在stdlib.h头文件中，在用到这些函数时应当用“#include<stdlib.h>”指令把stdlib.h头文件包含到程序文件中。",
        "tags": [
            "内存",
            "动态分配",
            "库函数",
            "临时分配域",
            "动态存储区"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00209",
        "title": "什么是基类型为void的指针变量？",
        "content": "基类型为void的指针变量，即void*型变量，不指向任何类型的数据。\n请注意：不要把“指向void类型”理解为能指向“任何类型”的数据，而应理解为“指向空类型”或“不指向确定的类型”的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。这种指针类型在调用动态存储分配函数时非常有效。",
        "tags": [
            "基类型",
            "空类型",
            "指针变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00210",
        "title": "一个地址型数据包含哪些信息？",
        "content": "一个地址型数据实际上包含3个信息：\n1. 表示内存编号的纯地址。\n2. 它本身的类型，即指针类型。对地址而言，首先，它不是一个数值型数据，不是按整型或浮点型方式存储，它是按指针型数据的存储方式存储的（虽然在Visual C++中也为指针变量分配4个字节，但不同于整型数据的存储形式）。指针型存储单元是专门用来存放地址的，指针型数据的存储形式就是地址的存储形式。\n3. 以它为标识的存储单元中存放的是什么类型的数据，即基类型。它不是一个简单的纯地址，还有一个指向的问题，也就是说它指向的是哪种类型的数据。如果没有这个信息，是无法通过地址存取存储单元中的数据的。",
        "tags": [
            "指针变量",
            "地址",
            "存储",
            "基类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00211",
        "title": "指针和指针变量有何区别？",
        "content": "指针就是地址，而指针变量是用来存放地址的变量。有人认为指针是类型名，指针的值是地址。这是不对的。类型是没有值的，只有变量才有值，正确的说法是指针变量的值是一个地址。不要杜撰出“地址的值”这样莫须有的名词。地址本身就是一个值。",
        "tags": [
            "指针",
            "指针变量",
            "地址",
            "存储",
            "基类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00212",
        "title": "&a与变量a是什么关系？",
        "content": "&a是变量a的地址，也可称为变量a的指针。",
        "tags": [
            "指针",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00213",
        "title": "指针变量是存放什么的变量？",
        "content": "指针变量是存放地址的变量。也可以说，指针变量是存放指针的变量。",
        "tags": [
            "指针变量",
            "地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00214",
        "title": "指针变量的值是什么？",
        "content": "指针变量的值是一个地址。也可以说，指针变量的值是一个指针。因此指针变量也可以称为地址变量。",
        "tags": [
            "指针变量",
            "地址",
            "指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00215",
        "title": "&是什么运算符？",
        "content": "&是取地址运算符，&a是a的地址。也可以说，&是取指针运算符，&a是变量a的指针（即指向变量a的指针）。",
        "tags": [
            "运算符",
            "地址",
            "指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00216",
        "title": "什么叫指向？",
        "content": "地址就意味着指向，因为通过地址能找到具有该地址的对象。对于指针变量来说，把谁的地址存放在指针变量中，就说此指针变量指向谁。",
        "tags": [
            "指针变量",
            "地址",
            "指向"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00217",
        "title": "指针变量具有哪些运算？",
        "content": "1. 指针变量加（减）一个整数：将该指针变量的原值（是一个地址）和它指向的变量所占用的存储单元的字节数相加（减）。\n2. 指针变量赋值：将一个变量地址赋给一个指针变量。\n3. 两个指针变量可以相减：如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之差是两个指针之间的元素个数。\n4. 两个指针变量比较：若两个指针指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量小于指向后面元素的指针变量。如果指向不同一数组则比较无意义。",
        "tags": [
            "指针变量",
            "地址",
            "指向"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00218",
        "title": "指针变量可以有空值吗？",
        "content": "指针变量可以有空值。",
        "tags": [
            "指针变量",
            "空值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00219",
        "title": "使用指针有哪些优点？",
        "content": "1. 提高程序效率；\n2. 在调用函数时当指针指向的变量的值改变时，这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值；\n3. 可以实现动态存储分配。",
        "tags": [
            "指针变量",
            "指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00220",
        "title": "什么是结构体？",
        "content": "C语言允许用户自己建立由不同类型数据组成的组合型数据结构，称为结构体。在其他一些高级语言中称为“记录”。",
        "tags": [
            "结构体类型",
            "数据类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00221",
        "title": "如何建立一个结构体类型？",
        "content": "可以在程序中自己建立一个结构体类型。声明一个结构体类型的一般形式为\n__struct__ __结构体名__\n  __{成员表列}__。\n例如：\n\n```c\nstruct Student\n  {  int num; //学号为整型\n     char name[20]; //姓名为字符串\n     char sex; //性别为字符型\n     int age; //年龄为整型\n     float score; //成绩为实型\n     char addr[30]; //地址为字符串\n  }; //注意最后有一个分号\n```\n\n上面由程序设计者指定了一个结构体类型struct Student（struct是声明结构体类型时必须使用的关键字，不能省略）。经过上面的指定，struct Student就是一个在本程序中可以使用的合法类型名，它向编译系统声明：这是一个“结构体类型”，它包括num、name、sex、age、score、addr等不同类型的成员。它和系统提供的标准类型（如int、char、float、double等）具有相似的作用，都可以用来定义变量，只不过int等类型是系统已声明的，而结构体类型是由用户根据需要在程序中指定的。\n注意：结构体类型的名字是由一个关键字struct和结构体名组合而成的（例如struct Student）。结构体名是由用户指定的，又称“结构体标记”（structure tag），以区别于其他结构体类型。上面的结构体声明中Student就是结构体名（结构体标记）。\n花括号内是该结构体所包括的子项，称为结构体的成员（member）。上例中的num、name、sex等都是成员。对各成员都应进行类型声明，即\n__类型名__ __成员名;__\n“成员表列”（member list）也称为“域表”（field list），每一个成员是结构体中的一个域。成员名命名规则与变量名相同。",
        "tags": [
            "结构体类型",
            "声明",
            "数据类型",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00222",
        "title": "在程序中可以建立多少个结构体类型？",
        "content": "结构体类型并非只有一种，而是可以设计出许多种结构体类型，各自包含不同的成员。",
        "tags": [
            "结构体类型",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00223",
        "title": "结构体的成员可以属于另一个结构体类型吗？",
        "content": "成员可以属于另一个结构体类型。例如：\n\n```c\nstruct Date //声明一个结构体类型struct Date\n  {  int month; //月\n     int day; //日\n     int year; //年\n  };\nstruct Student //声明一个结构体类型struct Student\n  {  int num;\n     char name[20];\n     char sex;\n     int age;\n     struct Date birthday; //成员birthday属于struct Date类型\n     char addr[30];\n  };\n```\n\n先声明一个struct Date类型，它代表“日期”，包括3个成员：month（月）、day（日）、year（年）。然后在声明struct Student类型时，将成员birthday指定为struct Date类型。已声明的类型struct Date与其他类型（如int，char）一样可以用来声明成员的类型。",
        "tags": [
            "结构体类型",
            "成员",
            "嵌套"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00224",
        "title": "如何定义结构体类型变量？",
        "content": "为了能在程序中使用结构体类型的数据，应当定义结构体类型的变量，并在其中存放具体的数据可以采取以下3种方法定义结构体类型变量。\n1. 先声明结构体类型,再定义该类型的变量\n假设已声明了一个结构体类型struct Student，可以用它来定义变量。例如：\n\n```c\nstruct Student student1,student2;\n```\n\n其中struct Student是结构体类型名，student1和student2是结构体变量名。这种形式和定义其他类型的变量形式（如int a,b;）是相似的。上面定义了student1和student2为struct Student类型的变量，这样student1和student2就具有struct Student类型的结构。\n在定义了结构体变量后，系统会根据结构体类型中包含的成员情况为之分配内存单元。\n这种方式是声明类型和定义变量分离，在声明类型后可以随时定义变量，比较灵活。\n2. 在声明类型的同时定义变量\n例如：\n\n```c\nstruct Student\n  {  int num;\n     char name[20];\n     char sex;\n     int age;\n     float score;\n     char addr[30];\n  }  student1,student2;\n```\n\n它的作用与第一种方法相同，但是在定义struct Student类型的同时定义两个struct Student类型的变量student1和student2。这种定义方法的一般形式为\n__struct__ __结构体名__\n  __{__  __成员表列__\n  __}__  __变量名表列;__\n声明类型和定义变量放在一起进行，能直接看到结构体的结构，比较直观，在写小程序时用此方式比较方便，但写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以使程序结构清晰，便于维护，所以一般不多用这种方式。\n3.不指定类型名而直接定义结构体类型变量\n其一般形式为\n__struct__\n  __{__ __成员表列__\n  __}__  __变量名表列;__\n指定了一个无名的结构体类型，它没有名字（不出现结构体名）。显然不能再以此结构体类型去定义其他变量。这种方式用得不多。",
        "tags": [
            "结构体变量",
            "数据类型",
            "定义",
            "结构体类型",
            "声明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00225",
        "title": "结构体类型与结构体变量有什么区别？",
        "content": "结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。",
        "tags": [
            "结构体变量",
            "结构体类型",
            "空间",
            "赋值",
            "存取",
            "运算"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00226",
        "title": "结构体类型中的成员名可以与程序中的变量名相同？",
        "content": "结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象，互不干扰",
        "tags": [
            "结构体类型",
            "变量名",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00227",
        "title": "如何进行结构体变量的初始化和引用？",
        "content": "1. 在定义结构体变量时可以对它的成员初始化。初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。注意：是对结构体变量初始化，而不是对结构体类型初始化。\nC99标准允许对某一成员初始化，如：\n\n```c\nstruct Student b=(.name=\"Zhang Fang\"}; //在成员名前有成员运算符\".\"\n```\n\n“.name”隐含代表结构体变量b中的成员b.name。其他未被指定初始化的数值型成员被系统初始化为0，字符型成员被系统初始化为'\\0'，指针型成员被系统初始化为NULL。\n2. 可以引用结构体变量中成员的值，引用方式为__结构体变量名.成员名__。例如，已定义了student1为 student类型的结构体变量，则student1.num表示student1变量中的num成员，即student1的num（学号）成员。\n在程序中可以对变量的成员赋值，例如：\n\n```c\nstudent1.num=10010;\n```\n\n“.”是成员运算符，它在所有的运算符中优先级最高，因此可以把student1.num作为一个整体来看待，相当于一个变量。上面赋值语句的作用是将整数10010赋给studentl变量中的成员num。\n注意：不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值，只能对结构体变量中的各个成员分别进行输入和输出。\n3. 如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。如果在结构体struct Student类型的成员中包含另一个结构体 struct date类型的成员 birthday，则引用成员的方式为\n\n```c\nstudent1.num //结构体变量student1中的成员num\nstudent1.birthday.month //结构体变量student1中的成员birthday中的成员month\n```\n\n不能用student1.birthday来访问student1变量中的成员birthday，因为birthday本身是一个结构体成员。",
        "tags": [
            "结构体变量",
            "结构体类型",
            "初始化",
            "引用",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00228",
        "title": "结构体变量的成员如何进行运算？",
        "content": "对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。例如：\n\n```c\nstudent2.score=studentl.score; //赋值运算\nsum=student1.score+student2.score; //加法运算\nstudent1.age++; //自加运算\n```\n\n由于“.”运算符的优先级最高，因此student1.age++是对（student1.age）进行自加运算，而不是先对age进行自加运算。",
        "tags": [
            "结构体变量",
            "结构体类型",
            "运算",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00229",
        "title": "结构体变量如何进行赋值？",
        "content": "同类的结构体变量可以互相赋值，如：\n\n```c\nstudent1=student2; //假设student1和student2已定义为同类型的结构体变量\n```\n\n",
        "tags": [
            "结构体变量",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00230",
        "title": "如何引用结构体变量的地址？",
        "content": "可以引用结构体变量成员的地址，也可以引用结构体变量的地址。例如：\n\n```c\nscanf(\"%d\",&student1.num); //输入student1.num的值\nprintf(\"%o\",&student1); //输出结构体变量student1的起始地址\n```\n\n但不能用以下语句整体读入结构体变量，例如：\n\n```c\nscanf(\"%d,%s,%c,%d,%f,%s\\n\",&student1);\n```\n\n结构体变量的地址主要用作函数参数，传递结构体变量的地址。",
        "tags": [
            "结构体变量",
            "地址",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00231",
        "title": "什么是结构体数组？",
        "content": "一个结构体变量中可以存放一组有关联的数据。如果有多组这样的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与数值型数组的不同之处在于每个数组元素都是一个结构体类型的数据，它们都分别包括各个成员项。",
        "tags": [
            "结构体数组",
            "结构体类型",
            "数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00232",
        "title": "如何定义并初始化一个结构体数组？",
        "content": "定义结构体数组的一般形式是\n__struct__ __结构体名__\n__{成员表列}__ __数组名[数组长度];__\n或先声明一个结构体类型，然后再用此类型定义结构体数组：\n__结构体类型__ __数组名[数组长度];__\n对结构体进行初始化的形式是在定义数组的后面加上：\n__={初值表列}__\n例如：\n\n```c\nstruct Person\n  {char name[20];\n   int count;\n  }leader[3]={\"Li\",0,\"Zhang\",0,\"Sun\",0}; //leader是结构体数组名\n```\n\n",
        "tags": [
            "结构体数组",
            "结构体类型",
            "定义",
            "初始化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00233",
        "title": "什么是结构体指针？",
        "content": "所谓结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。如果把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针变量就指向该结构体指针变量。\n指向结构体对象的指针变量既可指向结构体变量，也可指向结构体数组中的元素。指针变量的基类型必须与结构体变量的类型相同。例如：\n\n```c\nstruct Student *pt; //pt可以指向struct Student类型的变量或数组元素\n```\n\n",
        "tags": [
            "结构体数组",
            "结构体类型",
            "结构体指针",
            "起始地址"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00234",
        "title": "什么是指向运算符？",
        "content": "为了使用方便和直观，C语言允许把(*p).num用p->num代替，“->”代表一个箭头，p->num表示p所指向的结构体变量中的num成员。同样，(*p).name等价于p->name。“->”称为指向运算符。\n如果p指向一个结构体变量stu，以下3种用法等价：\n1. stu.成员名（如stu.num）；\n2. (*p).成员名（如(*p).num）；\n3. p->成员名（如p->num）。",
        "tags": [
            "结构体指针",
            "指向",
            "运算符",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00235",
        "title": "如何输出结构体数组的信息？",
        "content": "可以用指向结构体变量的指针来处理：\n1. 声明结构体类型struct Student，并定义结构体数组，同时使之初始化；\n2. 使p指向结构体数组的首元素，输出它指向的元素中的有关信息；\n3. 使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息；\n4. 再使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息。以此类推。",
        "tags": [
            "结构体指针",
            "输出",
            "结构体数组"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00236",
        "title": "将一个结构体变量的值传递给另一个函数，有什么方法？",
        "content": "1. 用结构体变量的成员作参数。例如，用stu[1].num或stu[2].name作函数实参将实参值传给形参。用法和用普通变量作实参是一样的，属于“值传递”方式。应当注意实参与形参的类型保持一致。\n2. 用结构体变量作实参。用结构体变量作实参时，采取的也是“值传递”的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参（也是结构体变量）的值，该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。\n3. 用指向结构体变量（或数组元素）的指针作实参，将结构体变量（或数组元素）的地址传给形参。",
        "tags": [
            "结构体变量",
            "参数",
            "函数",
            "结构体指针"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00237",
        "title": "什么是链表？",
        "content": "链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。由前面的介绍中已知：用数组存放数据时，必须事先定义固定的数组长度（即元素个数）。如果有的班级有100人，而有的班级只有30人，若用同一个数组先后存放不同班级的学生数据，则必须定义长度为100的数组。如果事先难以确定一个班的最多人数，则必须把数组定得足够大，以便能存放任何班级的学生数据，显然这将会浪费内存。链表则没有这种缺点，它根据需要开辟内存单元。\n链表有一个“头指针”变量，它存放一个地址，该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：\n1. 用户需要用的实际数据；\n2. 下一个结点的地址。\n头指针指向第1个元素，第1个元素又指向第2个元素……直到最后一个元素，该元素不再指向其他元素，它称为“表尾”，它的地址部分放一个“NULL”表示“空地址”），链表到此结束。\n可以看到链表中各元素在内存中的地址可以是不连续的。要找某一元素，必须先找到上一个元素，根据它提供的下一元素地址才能找到下一个元素。如果不提供“头指针”，则整个链表都无法访问。链表如同一条铁链一样，一环扣一环，中间是不能断开的。\n为了理解什么是链表，打一个通俗的比方：幼儿园的老师带领孩子出来散步，老师牵着第1个小孩的手，第1个小孩的另一只手牵着第2个孩子……这就是一个“链”，最后一个孩子有一只手空着，他是“链尾”。要找这个队伍，必须先找到老师，然后顺序找到每一个孩子。显然，链表这种数据结构，必须利用指针变量才能实现，即一个结点中应包含一个指针变量，用它存放下一结点的地址。",
        "tags": [
            "指针变量",
            "链表",
            "头指针",
            "结点",
            "表尾"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00238",
        "title": "如何利用结构体变量建立链表？",
        "content": "一个结构体变量包含若干成员，这些成员可以是数值类型、字符类型、数组类型，也可以是指针类型。用指针类型成员来存放下一个结点的地址。例如，可以设计这样一个结构体类型：\n\n```c\nstruct Student\n  {  int num;\n     float score;\n     struct Student *next; //next是指针变量，指向结构体变量\n  };\n```\n\n其中，成员num和score用来存放结点中的有用数据（用户需要用到的数据）。next是指针类型的成员，它指向struct Student类型数据（就是next所在的结构体类型）。一个指针类型的成员既可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型的数据。现在，next是struct Student类型中的一个成员，它又指向struct Student类型的数据。用这种方法就可以建立链表。链表中每一个结点都属于struct Student类型，它的成员next用来存放下一结点的地址。程序设计人员可以不必知道各结点的具体地址，只要保证将下一个结点的地址放到前一结点的成员next中即可。",
        "tags": [
            "结构体变量",
            "指针变量",
            "结点",
            "指向",
            "链表"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00239",
        "title": "什么是动态链表？",
        "content": "所谓建立动态链表是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。",
        "tags": [
            "链表",
            "动态链表",
            "结点"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00240",
        "title": "什么是共用体类型？",
        "content": "有时想用同一段内存单元存放不同类型的变量。例如，把一个短整型变量、一个字符型变量和一个实型变量放在同一个地址开始的内存单元中。以上3个变量在内存中占的字节数不同，但都从同一地址开始存放，也就是使用覆盖技术，后一个数据覆盖了前面的数据。这种使几个不同的变量共享同一段内存的结构，称为“共用体”类型的结构。",
        "tags": [
            "共用体",
            "变量类型",
            "地址",
            "覆盖"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00241",
        "title": "如何定义共用体类型变量？",
        "content": "定义共用体类型变量的一般形式为\n__union__ __共用体名__\n  __{成员表列__\n  __}变量表列;__\n例如：\n\n```c\nunion Data\n  {int i; //表示不同类型的变量i,ch,f可以存放到同一段存储单元中\n     char ch;\n     float f;\n  }a,b,c; //在声明类型同时定义变量\n```\n\n也可以将类型声明与变量定义分开：\n\n```c\nunion Data //声明共用体类型\n  {  int i;\n     char ch;\n     float f;\n  };\nunion Data a,b,c; //用共用体类型定义变量\n```\n\n即先声明一个union Data类型，再将a，b，c定义为union Data类型的变量。当然也可以直接定义共用体变量，例如：\n\n```c\nunion //没有定义共用体类型名\n  {  int i;\n     char ch;\n     float f;\n  }a,b,c;\n```\n\n",
        "tags": [
            "共用体",
            "变量类型",
            "地址",
            "覆盖"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00242",
        "title": "共用体和结构体有什么区别？",
        "content": "“共用体”与“结构体”的定义形式相似，但它们的含义是不同的。\n结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。\n“共用体”在一些书中也被称为“联合”。在阅读其他书籍时如遇“联合”一词，应理解为“共用体”。",
        "tags": [
            "共用体",
            "结构体",
            "联合",
            "内存"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00243",
        "title": "如何引用共用体变量？",
        "content": "只有先定义了共用体变量才能引用它。但应注意，不能引用共用体变量，而只能引用共用体变量中的成员。例如，前面定义了a，b，c为共用体变量，下面的引用方式是正确的：\n\n```c\na.i //引用共用体变量中的整型变量i\na.ch //引用共用体变量中的字符变量ch\na.f //引用共用体变量中的实型变量f\n```\n\n不能只引用共用体变量，也不能企图引用变量名来得到一个值。例如下面的引用是错误的：\n\n```c\nprintf(\"%d\",a);\n```\n\n因为a的存储区可以按不同的类型存放数据，有不同的长度，仅写共用体变量名a，系统无法知道究竟应输出哪一个成员的值。应该写成\n\n```c\nprintf(\"%d\",a.i);\n```\n\n或\n\n```c\nprintf(\"%c\",a.ch);\n```\n\n",
        "tags": [
            "共用体变量",
            "引用",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00244",
        "title": "共用体变量中可以存放多少个值？",
        "content": "同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。其道理是显然的，因为在每一个瞬时，存储单元只能有唯一的内容。也就是说，在共用体变量中只能存放一个值。如果有以下程序段：\n\n```c\nunion Date\n  {  int i;\n     char ch;\n     float f;\n  }a;\na.i=97;\n```\n\n表示将整数97存放在共用体变量中，可以用以下的输出语句：\n\n```c\nprintf(\"%d\",a.i); //输出整数97\nprintf(\"%c\",a.ch); //输出字符'a'\nprintf(\"%f\",a.f); //输出实数0.000000\n```\n\n其执行情况是：由于97是赋给a.i的，因此按整数形式存储在变量单元中，最后一个字节是“01100001”。如果用“%d”格式符输出a.i,就会输出整数97。如果想用“%c”格式符输出a.ch，系统会把存储单元中的信息按字符输出a。如果想用“%f”格式符输出a.f，系统会将存储单元中的信息按浮点数形式来处理，其数值部分为0，故输出0.000000。",
        "tags": [
            "共用体变量",
            "存储",
            "值",
            "输出"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00245",
        "title": "如何对共用体变量进行初始化？",
        "content": "可以对共用体变量初始化,但初始化表中只能有一个常量。下面用法不对：\n\n```c\nunion Data\n  {  int i;\n     char ch;\n     float f;\n  }a={1,'a',1.5}; //错误，不能初始化3个成员，它们占用同一段存储单元\nunion Data a={16}; //正确，对第1个成员初始化\nunion Data a={.ch='j'}; //C99允许对指定的一个成员初始化\n```\n\n",
        "tags": [
            "共用体变量",
            "初始化",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00246",
        "title": "如何对共用体变量进行赋值？",
        "content": "共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就取代。如果执行以下赋值语句：\n\n```c\na.ch='a';\na.f=1.5;\na.i=40;\n```\n\n在完成以上3个赋值运算以后，变量存储单元存放的是最后存入的40，原来的'a'和1.5都被覆盖了。此时如用“printf(\"%d\",a.ì);”输出a.i的值是40。而用“printf(\"%c\",a.ch);”输出的不是字符'a',而是字符''。因为在共用的存储单元中，按整数形式存放了40，现在要按%c格式输出a.ch，系统就到共用的存储单元去读数据，将存储单元中的内容按存储字符数据的规则解释，40是字符'('的ASCII码，因此输出字符'(’。\n因此在引用共用体变量时应十分注意当前存放在共用体变量中的究竟是哪个成员的值。\n同类型的共用体变量可以相互赋值，如：\n\n```c\nb=a; //a和b是同类型的共用体变量，合法\n```\n\n不能对共用体变量名赋值。",
        "tags": [
            "共用体变量",
            "赋值",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00247",
        "title": "共用体变量的地址是什么？",
        "content": "共用体变量的地址和它的各成员的地址都是同一地址。例如&a.i，&a.c，&a.f都是同一值。",
        "tags": [
            "共用体变量",
            "地址",
            "成员"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00248",
        "title": "共用体变量可以作为函数参数吗？",
        "content": "以前的C规定不能把共用体变量作为函数参数，但可以使用指向共用体变量的指针作函数参数。C99允许用共用体变量作为函数参数。",
        "tags": [
            "共用体变量",
            "指针",
            "函数参数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00249",
        "title": "共用体类型可以出现在结构体类型定义中吗？",
        "content": "共用体类型可以出现在结构体类型定义中。",
        "tags": [
            "共用体类型",
            "结构体类型",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00250",
        "title": "结构体类型可以出现在共用体类型定义中吗？",
        "content": "结构体类型可以出现在共用体类型定义中。可以在结构体类型的声明中声明共用体类型，也可以把它放在结构体类型声明之前。",
        "tags": [
            "共用体类型",
            "结构体类型",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00251",
        "title": "可以定义共用体数组吗？",
        "content": "可以定义共用体数组。",
        "tags": [
            "共用体类型",
            "数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00252",
        "title": "数组可以作为共用体类型的成员吗？",
        "content": "数组可以作为共用体类型的成员。",
        "tags": [
            "共用体类型",
            "数组",
            "定义"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00253",
        "title": "什么情况下会用到共用体类型的数据？",
        "content": "往往在数据处理中，有时需要对同一段空间安排不同的用途，这时用共用体类型比较方便，能增加程序处理的灵活性。",
        "tags": [
            "共用体类型",
            "数据",
            "用途"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00254",
        "title": "什么是枚举类型？",
        "content": "如果一个变量只有几种可能的值，则可以定义为枚举类型。所谓“枚举”就是指把可能的值一一列举出来，变量的值只限于列举出来的值的范围内。",
        "tags": [
            "枚举类型",
            "变量",
            "列举"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00255",
        "title": "如何声明一个枚举类型？",
        "content": "声明枚举类型用enum开头。例如：\n\n```c\nenum Weekday{sun,mon,tue,wed,thu,fri,sat};\n```\n\n",
        "tags": [
            "枚举类型",
            "声明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00256",
        "title": "如何定义一个枚举变量？",
        "content": "设已经声明了一个枚举类型：\n\n```c\nenum Weekday{sun,mon,tue,wed,thu,fri,sat};\n```\n\n然后可以用此类型来定义变量。例如：\n\n```c\nenum Weekday workday,weekend;\n```\n\nworkday和weekend被定义为枚举变量，花括号中的sun，mon，……，sat称为枚举元素或枚举常量。它们是用户指定的名字。枚举变量和其他数值型量不同，它们的值只限于花括号中指定的值之一。例如枚举变量workday和weekend的值只能是sun到sat之一。\n\n```c\nworkday=mon; //正确，mon是指定的枚举常量之一\nweekend=sun; //正确，sun是指定的枚举常量之一\nweekday=monday; //不正确，monday不是指定的枚举常量之一\n```\n\n枚举常量是由程序设计者命名的，用什么名字代表什么含义，完全由程序员根据自己的需要而定，并在程序中作相应处理。\n也可以不声明有名字的枚举类型，而直接定义枚举变量，例如：\n\n```c\nenum{sun,mon,tue,wed,thu,fri,sat} workday,weekend;\n```\n\n声明枚举类型的一般形式为__enum[枚举名]__ __{枚举元素列表};__，其中枚举名应遵循标识符的命名规则，上面的Weekday就是合法的枚举名。",
        "tags": [
            "枚举类型",
            "枚举变量",
            "命名",
            "枚举常量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00257",
        "title": "什么是枚举常量？",
        "content": "C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符（有名字）而把它们看作变量，不能对它们赋值。",
        "tags": [
            "枚举类型",
            "枚举常量",
            "赋值"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00258",
        "title": "枚举常量的值是什么？",
        "content": "每一个枚举元素都代表一个整数，C语言编译按定义时的顺序默认它们的值为0，1，2，3，4，5，…。在下面的定义中：\n\n```c\nenum Weekday{sun,mon,tue,wed,thu,fri,sat};\n```\n\nsun的值自动设为0，mon的值为1，…，sat的值为6.如果有赋值语句：\n\n```c\nworkday=mon;\n```\n\n相当于\n\n```c\nworkday=1;\n```\n\n枚举常量是可以引用和输出的。例如：\n\n```c\nprintf(\"%d\",workday);\n```\n\n得到整数1。\n也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：\n\n```c\nenum Weekday{sun=7,mon=1,tue,wed,thu,fri,sat}workday,week_end;\n```\n\n指定枚举常量sun的值是7，mon为1，以后顺序加1，sat为6。\n由于枚举型变量的值是整数，因此C99把枚举类型也作为整型数据中的一种，即用户自行定义的整数类型。",
        "tags": [
            "枚举类型",
            "赋值",
            "枚举常量",
            "输出",
            "整型数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00259",
        "title": "枚举元素可以用来作判断比较吗？",
        "content": "枚举元素可以用来作判断比较。例如：\n\n```c\nif(workday==mon)pass;\nif(workday>sun)pass;\n```\n\n枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。如果定义时人为来指定，则按上面默认规则处理，即第1个枚举元素的值为0，故mon>sun，sat>fri。",
        "tags": [
            "判断",
            "比较",
            "枚举元素"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00260",
        "title": "什么情况下需要指定一个新的类型名？",
        "content": "除了可以直接使用C提供的标准类型名（如int、char、float、double和long等）和程序编写者自己声明的结构体、共用体、枚举类型外，还可以用typedef指定新的类型名来代替已有的类型名。有以下两种情况：\n1. 简单地用一个新的类型名代替原有的类型名；\n2. 命名一个简单的类型名代替复杂的类型表示方法。",
        "tags": [
            "类型名",
            "指定",
            "代替"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00261",
        "title": "如何声明一个新类型名？",
        "content": "声明一个新类型名的方法是：\n1. 先按定义变量的方法写出定义体（如：int i;）。\n2. 将变量名换成新类型名（例如：将i换成Count）。\n3. 在最前面加上typedef（例如：typedef int Count）。\n4. 然后可以用新类型名去定义变量。\n简单地说，就是按定义变量的方式，把变量名换上新类型名，并且在最前面加typedef，就声明了新类型名代表原来的类型。例如：\n\n```c\nchar *p; //定义变量p的方式\nchar *String; //用新类型名String取代变量名p\ntypedef char *String; //加typedef\nString p; //用新类型名String定义变量，相当于char *p\n```\n\n习惯上，常把用typedef声明的类型名的第一个字母用大写表示，以便与系统提供的标准类型标识符相区别。",
        "tags": [
            "类型名",
            "声明",
            "定义",
            "变量名"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00262",
        "title": "声明一个新类型名是否等同于创造新的类型？",
        "content": "声明类型名的方法实际上是为特定的类型制定了一个同义字。用typedef声明是新类型名称为原有类型的typedef名称。\n用typedef只是对已经存在的类型指定一个新的类型名，而没有创造新的类型。",
        "tags": [
            "类型名",
            "声明",
            "同义字"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00263",
        "title": "typedef和#define有何区别？",
        "content": "typedef与#define表面上有相似之处，例如：\n\n```c\ntypedef int Count;\n```\n\n和\n\n```c\n#define Count int;\n```\n\n从表面看它们的作用都是用Count代表int。但事实上，它们二者是不同的。#define是在预编译时处理的，它只能作简单的字符串替换；而typedef是在编译阶段处理的。实际上它并不是作简单的字符串替换，例如：\n\n```c\ntypedef int Num[10];\nNum a;\n```\n\n并不是用“Num[10]”去代替“int”，而是采用如同定义变量的方法那样先生成一个类型名（将原来的变量名换成类型名），然后用它去定义变量。",
        "tags": [
            "类型名",
            "替换",
            "编译",
            "变量"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00264",
        "title": "使用typedef有何优点？",
        "content": "1. 用typedef声明数组类型、指针类型、结构体类型、共用体类型、枚举类型等，使得编程更加方便。例如定义数组，原来是用\n\n```c\nint a[10],b[10],c[10],d[10];\n```\n\n由于都是一维数组，大小也相同，可以先将此数组类型命名为一个新的名字Arr，即：\n\n```c\ntypedef int Arr[10];\n```\n\n然后用Arr去定义数组变量：\n\n```c\nArr a,b,c,d; //定义5个一维整型数组，各含10个元素\n```\n\nArr为数组类型，它包含10个元素。因此，a,b,c,d都被定义为一维数组，各含10个元素。\n可以看到，用typedef可以将数组类型和数组变量分离开来，利用数组类型可以定义多个数组变量。同样可以定义字符串类型、指针类型等。\n2. 当不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到它们的文件中用#include指令把它们包含到文件中。这样编程者就不需要在各文件中自己定义typedef名称了。\n3. 使用typedef名称有利于程序的通用与移植。有时程序会依赖于硬件特性，用typedef类型就便于移植。例如，有的计算机系统int型数据占用两个字节，数值范围为-32768~32767，而另外一些机器则以4个字节存放一个整数，数值范围为±21亿。如果把一个C程序从一个以4个字节存放整数的计算机系统移植到以2个字节存放整数的系统，按一般办法需要将定义变量中的每个int改为long，将“int a,b,c;”改为“long a,b,c;”。如果程序中有多处用int定义变量，则要改动多处。现可以用一个Integer来代替int：\n\n```c\ntypedef int Integer;\n```\n\n在程序中所有整型变量都用Integer定义。在移植时只须改动typedef定义体即可：\n\n```c\ntypedef long Integer;\n```\n\n",
        "tags": [
            "类型名",
            "变量",
            "定义",
            "声明"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00265",
        "title": "文件有哪些类型？",
        "content": "文件有不同的类型。在程序设计中，主要用到两种文件：\n1. 程序文件。包括源程序文件（后缀为.c）、目标文件（后缀为.obj）、可执行文件（后缀为.exe）等。这种文件的内容是程序代码。\n2. 数据文件。文件的内容不是程序，而是供程序运行时读写的数据。如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读人的数据。如一批学生的成绩数据、货物交易的数据等。",
        "tags": [
            "文件",
            "类型",
            "程序文件",
            "数据文件"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00266",
        "title": "什么是文件？",
        "content": "文件是程序设计中一个重要的概念。所谓“文件”一般指存储在外部介质上数据的集合。一批数据是以文件的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的。也就是说，如果想找存放在外部介质上的数据，必须先按文件名找到所指定的文件，然后再从该文件中读取数据。要向外部介质上存储数据也必须先建立一个文件（以文件名作为标志），才能向它输出数据。",
        "tags": [
            "文件",
            "磁盘",
            "存储",
            "数据",
            "操作系统"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00267",
        "title": "什么是数据流？",
        "content": "输入输出是数据传送的过程，数据如流水一样从一处流向另一处，因此常将输入输出形象地称为流，即数据流。流表示了信息从源到目的端的流动。在输入操作时，数据从文件流向计算机内存，在输出操作时，数据从计算机流向文件（如打印机、磁盘文件）。文件是由操作系统进行统一管理的，无论是用Word打开或保存文件，还是C程序中的输入输出都是通过操作系统进行的。“流”是一个传输通道，数据可以从运行环境（有关设备）流入程序中，或从程序流至运行环境。",
        "tags": [
            "数据流",
            "信息",
            "计算机",
            "数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00268",
        "title": "什么是字节流？",
        "content": "C语言把文件看作一个字符（或字节）的序列，即由一个一个字符（或字节）的数据顺序组成。一个输人输出流就是一个字符流或字节（内容为二进制数据）流。",
        "tags": [
            "字节流",
            "字符流",
            "字符",
            "字节",
            "文件"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00269",
        "title": "什么是流式文件？",
        "content": "C的数据文件由一连串的字符（或字节）组成，而不考虑行的界限，两行数据间不会自动加分隔符，对文件的存取是以字符（字节）为单位的。输入输出数据流的开始和结束仅受程序控制而不受物理符号（如回车换行符）控制，这就增加了处理的灵活性。这种文件称为流式文件。",
        "tags": [
            "流式文件",
            "文件",
            "字符",
            "字节"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00270",
        "title": "什么是文件名？文件名有哪些组成部分？",
        "content": "一个文件要有一个唯一的文件标识，以便用户识别和引用。文件标识包括3部分：\n1. 文件路径；\n2. 文件名主干；\n3. 文件后缀。\n文件路径表示文件在外部存储设备中的位置。如“D:\\CC\\temp\\file1.dat”，其中“D:\\CC\\temp\\”是文件路径，“file1”是文件名主干，“.dat”是文件后缀，表示file1.dat文件存放在D盘中的CC目录下的temp子目录下面。\n为方便起见，文件标识常被称为文件名，但应了解此时所称的文件名，实际上包括以上3部分内容，而不仅是文件名主干。文件名主干的命名规则遵循标识符的命名规则。后缀用来表示文件的性质，如：doc（Word生成的文件），txt（文本文件），dat（数据文件），c（C语言源程序文件），cpp（C++源程序文件），for（FORTRAN语言源程序文件），pas（Pascal语言源程序文件），obj（目标文件），exe（可执行文件），ppt（电子幻灯文件），bmp（图形文件）等。",
        "tags": [
            "文件名",
            "文件标识",
            "后缀",
            "路径"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00271",
        "title": "数据文件可以分为哪几类？",
        "content": "根据数据的组织形式，数据文件可分为ASCII文件和二进制文件。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件。如果要求在外存上以ASCII代码形式存储，则需要在存储前进行转换。ASCII文件又称文本文件，每一个字节存放一个字符的ASCII代码。",
        "tags": [
            "数据文件",
            "二进制文件",
            "ASCII文件",
            "存储"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00272",
        "title": "一个数据在磁盘上怎样存储呢？",
        "content": "字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以用二进制形式存储。如有整数10000，如果用ASCII码形式输出到磁盘，则在磁盘中占5个字节（每一个字符占一个字节），而用二进制形式输出，则在磁盘上只占4个字节（用Visual C++时）。\n用ASCII码形式输出时字节与字符一一对应，一个字节代表一个字符，因而便于对字符进行逐个处理，也便于输出字符。但一般占存储空间较多，而且要花费转换时间（二进制形式与ASCII码间的转换）。用二进制形式输出数值，可以节省外存空间和转换时间，把内存中的存储单元中的内容原封不动地输出到磁盘（或其他外部介质）上，此时每一个字节并不一定代表一个字符。如果程序运行过程中有的中间数据需要保存在外部介质上，以便在需要时再输入到内存，一般用二进制文件比较方便。在事务管理中，常有大批数据存放在磁盘上，随时调人计算机进行查询或处理，然后又把修改过的信息再存回磁盘，这时也常用二进制文件。",
        "tags": [
            "数据文件",
            "二进制形式",
            "ASCII形式",
            "存储",
            "磁盘"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00273",
        "title": "什么是文件缓冲区？",
        "content": "ANSIC标准采用“缓冲文件系统”处理数据文件，所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的C编译系统确定。\n每一个文件在内存中只有一个缓冲区，在向文件输出数据时，它就作为输出缓冲区，在从文件输入数据时，它就作为输入缓冲区。",
        "tags": [
            "缓冲文件",
            "文件缓冲区",
            "程序",
            "磁盘"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00274",
        "title": "文件中的信息是如何存储的？",
        "content": "每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息（如文件的名字、文件状态及文件当前位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为FILE。例如有一种C编译环境提供的stdio.h头文件中有以下的文件类型声明：\n\n```c\ntypedef struct\n  {  short level; //缓冲区“满”或“空”的程度\n     unsigned flags; //文件状态标志\n     char fd; //文件描述符\n     unsigned char hold; //如缓冲区无内容不读取字符\n     short bsize; //缓冲区的大小\n     unsigned char *buffer; //数据缓冲区的位置\n     unsigned char *curp; //文件位置标记指针当前的指向\n     unsigned istemp; //临时文件指示器\n     short token; //用于有效性检查\n  }FILE;\n```\n\n不同的C编译系统的FILE类型包含的内容不完全相同，但大同小异。对以上结构体中的成员及其含义可不深究，只须知道其中存放文件的有关信息即可。可以看到：FILE是以上结构体类型的自己命名的类型名称，FILE与上面的结构体类型等价。以上声明FILE结构体类型的信息包含在头文件“stdio.h”中。在程序中可以直接用FILE类型名定义变量。每一个FILE类型变量对应一个文件的信息区，在其中存放该文件的有关信息。例如，可以定义以下FILE类型的变量：\n\n```c\nFILE f1;\n```\n\n以上定义了一个结构体变量f1，用它来存放一个文件的有关信息。这些信息是在打开一个文件时由系统根据文件的情况自动放入的，在读写文件时需要用到这些信息，也会修改某些信息。例如在读一个字符后，文件信息区中的位置标记指针的指向就要改变。",
        "tags": [
            "文件类型",
            "变量",
            "结构体类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00275",
        "title": "什么是文件类型的指针？",
        "content": "一般不定义FILE类型的变量命名，也就是不通过变量的名字来引用这些变量，而是设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。这样使用起来方便。\n下面定义一个指向文件型数据的指针变量：\n\n```c\nFILE *fp;\n```\n\n定义fp是一个指向FILE类型数据的指针变量。可以使fp指向某一个文件的文件信息区（是一个结构体变量），通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。如果有n个文件，应设n个指针变量，分别指向n个FILE类型变量，以实现对n个文件的访问。\n为方便起见，通常将这种指向文件信息区的指针变量简称为指向文件的指针变量。",
        "tags": [
            "文件类型",
            "变量",
            "结构体类型"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00276",
        "title": "指向文件的指针变量指向哪里？",
        "content": "指向文件的指针变量并不是指向外部介质上的数据文件的开头，而是指向内存中的文件信息区的开头。",
        "tags": [
            "指针变量",
            "内存",
            "文件信息区"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00277",
        "title": "如何理解文件的打开与关闭过程？",
        "content": "实际上，所谓“打开”是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）。\n在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系。这样，就可以通过该指针变量对文件进行读写了。所谓“关闭”是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法进行对文件的读写了。",
        "tags": [
            "文件",
            "打开",
            "关闭",
            "指针变量",
            "文件缓冲区"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00278",
        "title": "如何打开数据文件？",
        "content": "ANSIC规定了用标准输入输出函数fopen来实现打开文件。fopen函数的调用方式为__fopen(文件名,使用文件方式);__。例如：\n\n```c\nfopen(\"a1\",\"r\");\n```\n\n表示要打开名字为a1的文件，使用文件方式为“读入”（read）。fopen函数的返回值是指向a1文件的指针（即a1文件信息区的起始地址）。通常将fopen函数的返回值赋给一个指向文件的指针变量。如：\n\n```c\nFILE *fp; //定义一个指向文件的指针变量fp\nfp=fopen(a1\",\"r\"); //将fopen函数的返回值赋给指针变量fp\n```\n\n这样fp就和文件a1相联系了，或者说，p指向了a1文件。可以看出，在打开一个文件时，通知编译系统以下3个信息：\n1. 需要打开文件的名字，也就是准备访问的文件的名字；\n2. 使用文件的方式（“读”还是“写”等）；\n3. 让哪一个指针变量指向被打开的文件。",
        "tags": [
            "文件",
            "打开",
            "指针变量",
            "方式"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00279",
        "title": "常用的打开数据文件的方式有哪些？它们有什么区别？",
        "content": "1. 用r方式打开的文件只能用于向计算机输入而不能用作向该文件输出数据，而且该文件应该已经存在，并存有数据，这样程序才能从文件中读数据。不能用r方式打开一个并不存在的文件，否则出错。\n2. 用w方式打开的文件只能用于向该文件写数据（即输出文件），而不能用来向计算机输入。如果原来不存在该文件，则在打开文件前新建立一个以指定的名字命名的文件。如果原来已存在一个以该文件名命名的文件，则在打开文件前先将该文件删去，然后重新建立一个新文件。\n3. 如果希望向文件末尾添加新的数据（不希望删除原有数据），则应该用a方式打开。但此时应保证该文件已存在；否则将得到出错信息。打开文件时，文件读写位置标记移到文件末尾。\n4. 用“r+”“w+”“a+”方式打开的文件既可用来输入数据，也可用来输出数据。用“r+”方式时该文件应该已经存在，以便计算机从中读数据。用“w+”方式则新建立一个文件，先向此文件写数据，然后可以读此文件中的数据。用“a+”方式打开的文件，原来的文件不被删去，文件读写位置标记移到文件末尾，可以添加，也可以读。\n5. 有12种文件使用方式，其中有6种是在第一个字母后面加了字母b的（如rb,wb,ab,rb+,wbt,ab+），b表示二进制方式。其实，带b和不带b只有一个区别，即对换行的处理。由于在C语言用一个'\\n'即可实现换行，而在Windows系统中为实现换行必须要用“回车”和“换行”两个字符，即'\\r'和'\\n'。因此，如果使用的是文本文件并且用w方式打开，在向文件输出时，遇到换行符'\\n'时，系统就把它转换为'\\r'和'\\n'两个字符。否则在Windows系统中查看文件时，各行连成一片，无法阅读。同样，如果有文本文件且用r方式打开，从文件读入时，遇到'\\r'和'\\n'两个连续的字符，就把它们转换为'\\n'一个字符。如果使用的是二进制文件，在向文件读写时，不需要这种转换。加b表示使用的是二进制文件，系统就不进行转换。\n6. 如果用wb的文件使用方式，并不意味着在文件输出时把内存中按ASCII形式保存的数据自动转换成二进制形式存储。输出的数据形式是由程序中采用什么读写语句决定的。例如，用fscanf和fprintf函数是按ASCII方式进行输入输出，而fread和fwrite函数是按二进制进行输入输出。\n在打开一个输出文件时，是选w还是wb方式，完全根据需要。如果需要对回车符进行转换的，就用w，如果不需要转换的，就用wb。带b只是通知编译系统：不必进行回车符的转换。如果是文本文件（例如一篇文章），显然需要转换，应该用w方式。如果是用二进制形式保存的一批数据，并不准备供人阅读，只是为了保存数据，就不必进行上述转换，可以用wb方式。一般情况下，带b的用于二进制文件，常称为二进制方式；不带b的用于文本文件，常称为文本方式。从理论上说，文本文件也可以wb方式打开，但无必要。",
        "tags": [
            "文件",
            "打开",
            "二进制",
            "方式",
            "转换",
            "输入",
            "输出"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00280",
        "title": "文件打开出错时有什么提示？",
        "content": "如果不能实现“打开”的任务，fopen函数将会带回一个出错信息。出错的原因可能是：用r方式打开一个并不存在的文件；磁盘出故障；磁盘已满无法建立新文件等。此时fopen函数将带回一个空指针值NULL（在stdio.h头文件中，NULL已被定义为 0）。\n常用下面的方法打开一个文件：\n\n```c\nif((fp= fopen(\"file1\",\"r\"))==NULL)\n    {printf(\"cannot open this file\\n\");\n     exit(0);\n    }\n```\n\n即先检查打开文件的操作有否出错，如果有错就在终端上输出can not open this file。exit函数的作用是关闭所有文件，终止正在执行的程序，待用户检查出错误，修改后重新运行。",
        "tags": [
            "文件",
            "打开",
            "错误"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00281",
        "title": "什么是标准流文件？",
        "content": "程序中可以使用3个标准的流文件——标准输入流、标准输出流和标准出错输出流。系统已对这3个文件指定了与终端的对应关系。标准输入流是从终端的输如，标准输出流是向终端的输出，标准出错输出流是当程序出错时将出错信息发送到终端。\n程序开始运行时系统自动打开这3个标准流文件。因此，程序编写者不需要在程序中用fopen函数打开它们。所以以前我们用到的从终端输入或输出到终端都不需要打开终端文件。系统定义了3个文件指针变量stdin，stdout和stderr，分别指向标准输入流、标准输出流和标准出错输出流。可以通过这3个指针变量对以上3种流进行操作，它们都以终端作为输入输出对象。例如程序中指定要从stdin所指的文件输入数据，就是指从终端键盘输人数据。",
        "tags": [
            "流文件",
            "终端",
            "输入",
            "输出",
            "错误"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00282",
        "title": "为什么在程序终止前需要关闭所有文件？",
        "content": "在使用完一个文件后应该关闭它，以防止它再被误用。“关闭”就是撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，也就是文件指针变量与文件“脱钩”，此后不能再通过该指针对原来与其相联系的文件进行读写操作，除非再次打开，使该指针变量重新指向该文件。\n如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。",
        "tags": [
            "文件",
            "指针变量",
            "关闭",
            "缓冲区",
            "数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00283",
        "title": "如何关闭文件？",
        "content": "关闭文件用fclose数。fclose数调用的一般形式为__fclose(文件指针);__。例如：\n\n```c\nfclose(fp);\n```\n\n前面曾把打开文件（用fopen函数）时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后不再指向该文件。\n用fclose函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撒销文件信息区。fclose函数也带回一个值，当成功地执行了关闭操作，则返回值为0；否则返回EOF(-1)。",
        "tags": [
            "文件",
            "关闭",
            "指针",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00284",
        "title": "什么是文件的顺序读写？",
        "content": "文件打开之后，就可以对它进行读写了。在顺序写时。先写人的数据存放在文件中前面的位置，后写入的数据存放在文件中后面的位置。在顺序读时，先读文件中前面的数据，后读文件中后面的数据。也就是说，对顺序读写来说，对文件读写数据的顺序和数据在文件中的物理顺序是一致的。顺序读写需要用库函数实现。",
        "tags": [
            "文件",
            "读写",
            "顺序",
            "数据"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00285",
        "title": "怎样向文件读写字符？",
        "content": "对文本文件读入或输出一个字符的函数分别为fgetc、fputc。调用形式如下：\n\n``c\nfgetc(fp); //从fp指向的文件读入一个字符\nfputc(ch,fp); //把字符ch写到文件指针变量fp所指向的文件中\n```\n\n若文件读成功，则fgetc带回所读的字符，失败则返回文件结束标志EOF（即-1）；若输出成功，fputc的返回值就是输出的字符，输出失败则返回EOF（即-1）。",
        "tags": [
            "文件",
            "读写",
            "字符",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00286",
        "title": "怎样向文件读写字符串？",
        "content": "C语言允许通过函数fgets和fputs一次读写一个字符串，例如：\n\n```c\nfgets(str,n,fp);\n```\n\n作用是从fp所指向的文件中读入一个长度为n-1的字符串，并在最后加一个'\\0'字符，然后把这n个字符存放到字符数组str中。若读成功，返回地址str，失败则返回NULL。\n\n```c\nfputs(str,fp);\n```\n\n则是把str所指向的字符串写到文件指针变量fp所指向的文件中。若输出成功，返回0；否则返回非0值。\nfgets和fputs这两个函数的功能类似于gets和puts函数，只是gets和puts以终端为读写对象，而fgets和fputs函数以指定的文件作为读写对象。",
        "tags": [
            "文件",
            "读写",
            "字符",
            "函数"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00287",
        "title": "如何用格式化的方式读写文本文件？",
        "content": "前面进行的是字符的输入输出，而实际上数据的类型是丰富的。可以对文件进行格式化输入输出，这时就要用fprintf函数和fscanf函数。从函数名可以看到，它们只是在printf和scanf的前面加了一个字母f。它们的作用与printf函数和scanf函数相仿，都是格式化读写函数。只有一点不同：fprintf和fscanf函数的读写对象不是终端而是文件。它们的一般调用方式为\n\n__fprintf(文件指针,格式字符串,输出表列);__\n__fscanf(文件指针,格式字符串,输入表列);__\n例如：\n\n```c\nfprintf (fp,\"%d,%6.2f\",i,f);\n```\n\n它的作用是将int型变量i和float型变量f的值按%d和%6.2f的格式输出到fp指向的文件中。若i=3，f=4.5，则输出到磁盘文件上的是以下的字符：\n\n3,  4.50\n\n这是和输出到屏幕的情况相似的，只是它没有输出到屏幕而是输出到文件而已。同样，用以下fscanf函数可以从磁盘文件上读入ASCII字符：\n\n```c\nfscanf(fp,\"%d,%f\",&i,&f);\n```\n\n磁盘文件上如果有字符“3,4,5”，则从磁盘文件中读取整数3送给整型变量i，读取实数4,5送给float型变量f。\n用fprint和fscanf函数对磁盘文件读写，使用方便，容易理解。但由于在输入时要将文件中的ASCII码转换为二进制形式再保存在内存变量中，在输出时又要将内存中的二进制形式转换成字符，要花费较多时间。因此，在内存与磁盘频繁交换数据的情况下，最好不用fprintf和fscanf函数，而用fread和fwrite函数进行二进制的读写。",
        "tags": [
            "文件",
            "读写",
            "数据",
            "函数",
            "格式化"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00288",
        "title": "如何用二进制方式向文件读写一组数据？",
        "content": "在程序中不仅需要一次输入输出一个数据，而且常常需要一次输入输出一组数据（如数组或结构体变量的值）。C语言允许用fread函数从文件中读一个数据块，用fwrite函数向文件写一个数据块。在读写时是以二进制形式进行的。在向磁盘写数据时，直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上，在读入时也是将磁盘文件中若于字节的内容一批读入内存。\n它们的一般调用形式为：\n\nfread(buffer,size,count,fp);\nfwrite(buffer,size,count,fp);\n\n其中：\nbuffer：是一个地址。对fread来说，它是用来存放从文件读入的数据的存储区的地址。对fwrite来说，是要把此地址开始的存储区中的数据向文件输出（以上指的是起始地址）。\nsize：要读写的字节数。\ncount：要读写多少个数据项（每个数据项长度为size）。\nfp：FILE类型指针。\n在打开文件时指定用二进制文件，这样就可以用fread和fwrite函数读写任何类型的信息，例如：\n\n```c\nfread(f,4,10,fp);\n```\n\n其中，f是一个float型数组名（代表数组首元素地址）。这个函数从p所指向的文件读入10个4个字节的数据，存储到数组f中。\n如果有一个Struct student_type结构体类型：\n\n```c\nstruct Student_type\n  {  char name[10];\n     int num;\n     int age;\n     char addr[30];\n  }stud[40];\n```\n\n定义了一个结构体数组stud，有40个元素，每一个元素用来存放一个学生的数据（包括姓名、学号、年龄、地址）。假设学生的数据已存放在磁盘文件中，可以用下面的for语句和fread函数读人40个学生的数据：\n\n```c\nfor(i=0;i<40:i++)\n  fread(&stud[i],sizeof(struct Student_type),1,fp);\n```\n\n执行40次循环，每次从fp指向的文件中读入结构体数组stu的一个元素。\n同样，以下for语句和fwrite函数可以将内存中的学生数据输出到磁盘文件中去：\n\n```c\nfor(i=0;i<40;i++)\n  fwrite(&stud[i],sizeof(struct Student_type),1,fp);\n```\n\nfread或 fwrite函数的类型为int型，如果fread或fwrite函数执行成功，则函数返回值为形参count的值（一个整数），即输入或输出数据项的个数（今为1）。",
        "tags": [
            "文件",
            "读写",
            "数据",
            "函数",
            "二进制"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00289",
        "title": "如何区分数据存储方式、文件分类、文件打开方式、文件读写函数的文本和二进制方式？",
        "content": "1. 数据的存储方式\n文本方式：数据以字符方式（ASCII代码）存储到文件中。如整数12，送到文件时占2个字节，而不是4个字节。以文本方式保存的数据便于阅读。\n二进制方式：数据按在内存的存储状态原封不动地复制到文件。如整数12，送到文件时和在内存中一样占4个字节。\n2. 文件的分类\n文本文件（ASCII文件）：文件中全部为ASCII字符。\n二进制文件：按二进制方式把在内存中的数据复制到文件的，称为二进制文件，即映像文件。\n3. 文件的打开方式\n文本方式：不带b的方式，读写文件时对换行符进行转换。\n二进制方式：带b的方式，读写文件时对换行符不进行转换。\n4. 文件读写函数\n文本读写函数：用来向文本文件读写字符数据的函数（如fgetc,fgets,fputc,fputs,fscanf,fprintf等）\n二进制读写函数：用来向二进制文件读写二进制数据的函数（如getw,putw,fread,fwrite等）。\nC语言不禁止文本方式与二进制方式之间出现某些交叉，例如用二进制方式存储的一个整数，也可以用文本读写函数（如fscanf画函数）读取；用二进制方式也可以打开文本文件。这些虽然合法，但往往会导致结果出错。不提倡这种随意的、不规范的用法。提倡用文本方式打开文本文件，用文本读写函数进行读写。对二进制文件亦然。",
        "tags": [
            "文件",
            "文本",
            "二进制",
            "读写",
            "存储",
            "数据",
            "分类"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "定义"
        },
        "id": "00290",
        "title": "什么是文件的随机访问？",
        "content": "对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高。例如文件中有1000个数据，若只查第1000个数据，必须先逐个读入前面999个数据，才能读入第1000个数据。如果文件中存放一个城市几百万人的资料，若按此方法查某一人的情况，等待的时间可能是不能忍受的。\n随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数据进行访问。显然这种方法比顺序访问效率高得多。",
        "tags": [
            "文件",
            "访问",
            "效率",
            "顺序"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "概念"
        },
        "id": "00291",
        "title": "文件的位置标记在文件读写过程中有何作用？",
        "content": "为了对读写进行控制，系统为每个文件设置了一个文件读写位置标记（简称文件位置标记或文件标记），用来指示“接下来要读写的下一个字符的位置”。一般情况下，在对字符文件进行顺序读写时，文件位置标记指向文件开头。这时如果对文件进行读的操作，就读第1个字符，然后文件位置标记向后移一个位置；在下一次执行读的操作时，就将位置标记指向的第2个字符读入。依此类推，遇到文件尾结束。\n如果是顺序写文件，则每写完一个数据后，文件位置标记顺序向后移一个位置，然后在下一次执行写操作时把数据写入位置标记所指的位置，直到把全部数据写完。此时文件位置标记在最后一个数据之后。\n可以根据读写的需要，人为地移动文件位置标记的位置。文件位置标记可以向前移、向后移，移到文件头或文件尾，然后对该位置进行读写。显然这就不是顺序读写了，而是随机读写。\n对流式文件既可以进行顺序读写，也可以进行随机读写，关键在于控制文件的位置标记。如果文件位置标记是按字节位置顺序移动的，就是顺序读写。如果能将文件位置标记按需要移动到任意位置，就可以实现随机读写。所谓随机读写，是指读写完上一个字符（字节）后，并不一定要读写其后续的字符（字节），而可以读写文件中任意位置上所需要的字符（字节）。即对文件读写数据的顺序和数据在文件中的物理顺序一般是不一致的。可以在任何位置写人数据，在任何位置读取数据。",
        "tags": [
            "文件",
            "标记",
            "位置",
            "移动",
            "顺序",
            "随机"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00292",
        "title": "如何实现文件位置标记的定位？",
        "content": "可以强制使文件位置标记指向人民指定的位置。可以用以下函数实现：\n1. 用rewind函数使文件位置标记指向文件开头。\nrewind函数的作用是使文件位置标记重新返回文件的开头，此函数没有返回值。\n2. 用fseek函数改变文件位置标记\nfseek函数的调用形式为__fseek(文件类型指针,位移量,起始点);__。“起始点”用0,1或2代替，0代表“文件开始位置”，1为“当前位置”，2为“文件末尾位置”。“位移量”指以“起始点”为基点，向前移动的字节数。位移量应是long型数据（在数字的末尾加上字母L，就表示是long型）。fseek函数一般用于二进制文件。下面是fseek函数调用的几个例子：\n\n```c\nfseek(fp,100L,0); //将文件位置标记向前移到离文件开头100个字节处\nfseek(fp,50L,1); //将文件位置标记向前移到离当前位置50个字节处\nfseek(fp,-10L,2); //将文件位置标记从文件末尾处向后退10个字节\n```\n\n3. 用ftell函数测定文件位置标记的当前位置\nftell函数的作用是得到流式文件中文件位置标记的当前位置。由于文件中的文件位置标记经常移动，人们往往不容易知道其当前位置，所以常用ftell函数得到当前位置，用相对于文件开头的位移量来表示。如果调用函数时出错（如不存在fp指向的文件），ftell函数返回值为-1。例如：\n\n```c\ni=ftell(fp); //变量i存放文件当前位置\nif(i==-1L)printf(\"error\\n\"); //如果调用函数时出错，输出error\n```\n\n",
        "tags": [
            "文件",
            "标记",
            "位置",
            "函数",
            "定位"
        ]
    },
    {
        "part": {
            "section": "课内定义概念",
            "classification": "用法"
        },
        "id": "00293",
        "title": "如何检测文件读写过程中可能产生的错误？",
        "content": "C提供一些函数用来检查输人输出函数调用时可能出现的错误。\n1. ferror函数\n在调用各种输入输出函数（如putc,getc,fread和fwrite等）时，如果出现错误，除了函数返回值有所反映外，还可以用ferror函数检查。它的一般调用形式为\n\n```c\nferror(fp);\n```\n\n如果ferror返回值为0（假），表示未出错；如果返回一个非零值，表示出错。\n应该注意，对同一个文件每一次调用输入输出函数，都会产生一个新的ferror函数值。因此，应当在调用一个输入输出函数后立即检查ferror函数的值，否则信息会丢失在执行fopen函数时，ferror函数的初始值自动置为0。\n2. clearerr函数\nclearerr的作用是使文件出错标志和文件结束标志置为0。假设在调用一个输入输出函数时出现错误，ferror函数值为一个非零值。应该立即调用clearerr(fp)，使ferror(fp)的值变成0，以便再进行下一次的检测。\n只要出现文件读写出错标志，它就一直保留，直到对同一文件调用clearerr函数或rewind函数，或任何其他一个输人输出函数。",
        "tags": [
            "文件",
            "错误",
            "位置",
            "函数",
            "检查"
        ]
    }
]
